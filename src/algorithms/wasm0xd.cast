# Copyright 2016 WebAssembly Community Group participants
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


# Defines the CAST algorithm for reading/writing WASM files.

(header (u32.const 0x6d736163) (u32.const 0x0))
(header (u32.const 0x6d736100) (u32.const 0xd))
(void)

(declarations)

(literal.action.base (u32.const 1001))

#### WASM opcodes.

(literal 'inst.unreachable'         (u8.const 0x00))
(literal 'inst.nop'                 (u8.const 0x01))
(literal 'inst.block'               (u8.const 0x02))
(literal 'inst.loop'                (u8.const 0x03))
(literal 'inst.if'                  (u8.const 0x04))
(literal 'inst.else'                (u8.const 0x05))
(literal 'inst.end'                 (u8.const 0x0b))
(literal 'inst.br'                  (u8.const 0x0c))
(literal 'inst.br_if'               (u8.const 0x0d))
(literal 'inst.br_table'            (u8.const 0x0e))
(literal 'inst.return'              (u8.const 0x0f))
(literal 'inst.call'                (u8.const 0x10))
(literal 'inst.call_indirect'       (u8.const 0x11))
(literal 'inst.drop'                (u8.const 0x1a))
(literal 'inst.select'              (u8.const 0x1b))
(literal 'inst.get_local'           (u8.const 0x20))
(literal 'inst.set_local'           (u8.const 0x21))
(literal 'inst.tee_local'           (u8.const 0x22))
(literal 'inst.get_global'          (u8.const 0x23))
(literal 'inst.set_global'          (u8.const 0x24))
(literal 'inst.i32.load'            (u8.const 0x28))
(literal 'inst.i64.load'            (u8.const 0x29))
(literal 'inst.f32.load'            (u8.const 0x2a))
(literal 'inst.f64.load'            (u8.const 0x2b))
(literal 'inst.i32.load8_s'         (u8.const 0x2c))
(literal 'inst.i32.load8_u'         (u8.const 0x2d))
(literal 'inst.i32.load16_s'        (u8.const 0x2e))
(literal 'inst.i32.load16_u'        (u8.const 0x2f))
(literal 'inst.i64.load8_s'         (u8.const 0x30))
(literal 'inst.i64.load8_u'         (u8.const 0x31))
(literal 'inst.i64.load16_s'        (u8.const 0x32))
(literal 'inst.i64.load16_u'        (u8.const 0x33))
(literal 'inst.i64.load32_s'        (u8.const 0x34))
(literal 'inst.i64.load32_u'        (u8.const 0x35))
(literal 'inst.i32.store'           (u8.const 0x36))
(literal 'inst.i64.store'           (u8.const 0x37))
(literal 'inst.f32.store'           (u8.const 0x38))
(literal 'inst.f64.store'           (u8.const 0x39))
(literal 'inst.i32.store8'          (u8.const 0x3a))
(literal 'inst.i32.store16'         (u8.const 0x3b))
(literal 'inst.i64.store8'          (u8.const 0x3c))
(literal 'inst.i64.store16'         (u8.const 0x3d))
(literal 'inst.i64.store32'         (u8.const 0x3e))
(literal 'inst.current_memory'      (u8.const 0x3f))
(literal 'inst.grow_memory'         (u8.const 0x40))
(literal 'inst.i32.const'           (u8.const 0x41))
(literal 'inst.i64.const'           (u8.const 0x42))
(literal 'inst.f32.const'           (u8.const 0x43))
(literal 'inst.f64.const'           (u8.const 0x44))
(literal 'inst.i32.eqz'             (u8.const 0x45))
(literal 'inst.i32.eq'              (u8.const 0x46))
(literal 'inst.i32.ne'              (u8.const 0x47))
(literal 'inst.i32.lt_s'            (u8.const 0x48))
(literal 'inst.i32.lt_u'            (u8.const 0x49))
(literal 'inst.i32.gt_s'            (u8.const 0x4a))
(literal 'inst.i32.gt_u'            (u8.const 0x4b))
(literal 'inst.i32.le_s'            (u8.const 0x4c))
(literal 'inst.i32.le_u'            (u8.const 0x4d))
(literal 'inst.i32.ge_s'            (u8.const 0x4e))
(literal 'inst.i32.ge_u'            (u8.const 0x4f))
(literal 'inst.i64.eqz'             (u8.const 0x50))
(literal 'inst.i64.eq'              (u8.const 0x51))
(literal 'inst.i64.ne'              (u8.const 0x52))
(literal 'inst.i64.lt_s'            (u8.const 0x53))
(literal 'inst.i64.lt_u'            (u8.const 0x54))
(literal 'inst.i64.gt_s'            (u8.const 0x55))
(literal 'inst.i64.gt_u'            (u8.const 0x56))
(literal 'inst.i64.le_s'            (u8.const 0x57))
(literal 'inst.i64.le_u'            (u8.const 0x58))
(literal 'inst.i64.ge_s'            (u8.const 0x59))
(literal 'inst.i64.ge_u'            (u8.const 0x5a))
(literal 'inst.f32.eq'              (u8.const 0x5b))
(literal 'inst.f32.ne'              (u8.const 0x5c))
(literal 'inst.f32.lt'              (u8.const 0x5d))
(literal 'inst.f32.gt'              (u8.const 0x5e))
(literal 'inst.f32.le'              (u8.const 0x5f))
(literal 'inst.f32.ge'              (u8.const 0x60))
(literal 'inst.f64.eq'              (u8.const 0x61))
(literal 'inst.f64.ne'              (u8.const 0x62))
(literal 'inst.f64.lt'              (u8.const 0x63))
(literal 'inst.f64.gt'              (u8.const 0x64))
(literal 'inst.f64.le'              (u8.const 0x65))
(literal 'inst.f64.ge'              (u8.const 0x66))
(literal 'inst.i32.clz'             (u8.const 0x67))
(literal 'inst.i32.ctx'             (u8.const 0x68))
(literal 'inst.i32.popcnt'          (u8.const 0x69))
(literal 'inst.i32.add'             (u8.const 0x6a))
(literal 'inst.i32.sub'             (u8.const 0x6b))
(literal 'inst.i32.mul'             (u8.const 0x6c))
(literal 'inst.i32.div_s'           (u8.const 0x6d))
(literal 'inst.i32.div_u'           (u8.const 0x6e))
(literal 'inst.i32.rem_s'           (u8.const 0x6f))
(literal 'inst.i32.rem_u'           (u8.const 0x70))
(literal 'inst.i32.and'             (u8.const 0x71))
(literal 'inst.i32.or'              (u8.const 0x72))
(literal 'inst.i32.xor'             (u8.const 0x73))
(literal 'inst.i32.shl'             (u8.const 0x74))
(literal 'inst.i32.shr_s'           (u8.const 0x75))
(literal 'inst.i32.shr_u'           (u8.const 0x76))
(literal 'inst.i32.rotl'            (u8.const 0x77))
(literal 'inst.i32.rotr'            (u8.const 0x78))
(literal 'inst.i64.clz'             (u8.const 0x79))
(literal 'inst.i64.ctx'             (u8.const 0x7a))
(literal 'inst.i64.popcnt'          (u8.const 0x7b))
(literal 'inst.i64.add'             (u8.const 0x7c))
(literal 'inst.i64.sub'             (u8.const 0x7d))
(literal 'inst.i64.mul'             (u8.const 0x7e))
(literal 'inst.i64.div_s'           (u8.const 0x7f))
(literal 'inst.i64.div_u'           (u8.const 0x80))
(literal 'inst.i64.rem_s'           (u8.const 0x81))
(literal 'inst.i64.rem_u'           (u8.const 0x82))
(literal 'inst.i64.and'             (u8.const 0x83))
(literal 'inst.i64.or'              (u8.const 0x84))
(literal 'inst.i64.xor'             (u8.const 0x85))
(literal 'inst.i64.shl'             (u8.const 0x86))
(literal 'inst.i64.shr_s'           (u8.const 0x87))
(literal 'inst.i64.shr_u'           (u8.const 0x88))
(literal 'inst.i64.rotl'            (u8.const 0x89))
(literal 'inst.i64.rotr'            (u8.const 0x8a))
(literal 'inst.f32.abs'             (u8.const 0x8b))
(literal 'inst.f32.neg'             (u8.const 0x8c))
(literal 'inst.f32.ceil'            (u8.const 0x8d))
(literal 'inst.f32.floor'           (u8.const 0x8e))
(literal 'inst.f32.trunc'           (u8.const 0x8f))
(literal 'inst.f32.nearest'         (u8.const 0x90))
(literal 'inst.f32.sqrt'            (u8.const 0x91))
(literal 'inst.f32.add'             (u8.const 0x92))
(literal 'inst.f32.sub'             (u8.const 0x93))
(literal 'inst.f32.mul'             (u8.const 0x94))
(literal 'inst.f32.div'             (u8.const 0x95))
(literal 'inst.f32.min'             (u8.const 0x96))
(literal 'inst.f32.max'             (u8.const 0x97))
(literal 'inst.f32.copysign'        (u8.const 0x98))
(literal 'inst.f64.abs'             (u8.const 0x99))
(literal 'inst.f64.neg'             (u8.const 0x9a))
(literal 'inst.f64.ceil'            (u8.const 0x9b))
(literal 'inst.f64.floor'           (u8.const 0x9c))
(literal 'inst.f64.trunc'           (u8.const 0x9d))
(literal 'inst.f64.nearest'         (u8.const 0x9e))
(literal 'inst.f64.sqrt'            (u8.const 0x9f))
(literal 'inst.f64.add'             (u8.const 0xa0))
(literal 'inst.f64.sub'             (u8.const 0xa1))
(literal 'inst.f64.mul'             (u8.const 0xa2))
(literal 'inst.f64.div'             (u8.const 0xa3))
(literal 'inst.f64.min'             (u8.const 0xa4))
(literal 'inst.f64.max'             (u8.const 0xa5))
(literal 'inst.f64.copysign'        (u8.const 0xa6))
(literal 'inst.i32.wrap/i64'        (u8.const 0xa7))
(literal 'inst.i32.trunc_s/f32'     (u8.const 0xa8))
(literal 'inst.i32.trunc_u/f32'     (u8.const 0xa9))
(literal 'inst.i32.trunc_s/f64'     (u8.const 0xaa))
(literal 'inst.i32.trunc_u/f64'     (u8.const 0xab))
(literal 'inst.i64.extend_s/i32'    (u8.const 0xac))
(literal 'inst.i64.extend_u/i32'    (u8.const 0xad))
(literal 'inst.i64.trunc_s/f32'     (u8.const 0xae))
(literal 'inst.i64.trunc_u/f32'     (u8.const 0xaf))
(literal 'inst.i64.trunc_s/f64'     (u8.const 0xb0))
(literal 'inst.i64.trunc_u/f64'     (u8.const 0xb1))
(literal 'inst.f32.convert_s/i32'   (u8.const 0xb2))
(literal 'inst.f32.convert_u/i32'   (u8.const 0xb3))
(literal 'inst.f32.convert_s/i64'   (u8.const 0xb4))
(literal 'inst.f32.convert_u/i64'   (u8.const 0xb5))
(literal 'inst.f32.demote/f64'      (u8.const 0xb6))
(literal 'inst.f64.convert_s/i32'   (u8.const 0xb7))
(literal 'inst.f64.convert_u/i32'   (u8.const 0xb8))
(literal 'inst.f64.convert_s/i64'   (u8.const 0xb9))
(literal 'inst.f64.convert_u/i64'   (u8.const 0xba))
(literal 'inst.f64.promote/f32'     (u8.const 0xbb))
(literal 'inst.i32.reinterpret/f32' (u8.const 0xbc))
(literal 'inst.i64.reinterpret/f64' (u8.const 0xbd))
(literal 'inst.f32.reinterpret/i32' (u8.const 0xbe))
(literal 'inst.f64.reinterpret/i64' (u8.const 0xbf))

#### Encoding of sections in a WASM file.

(literal 'unknown.section'  (u32.const 0))
(literal 'type.section'     (u32.const 1))
(literal 'import.section'   (u32.const 2))
(literal 'function.section' (u32.const 3))
(literal 'table.section'    (u32.const 4))
(literal 'memory.section'   (u32.const 5))
(literal 'global.section'   (u32.const 6))
(literal 'export.section'   (u32.const 7))
(literal 'start.section'    (u32.const 8))
(literal 'element.section'  (u32.const 9))
(literal 'code.section'     (u32.const 10))
(literal 'data.section'     (u32.const 11))

#### Encoding of the kind of symbol being defined.

(literal 'external.kind.function' (u8.const 0))
(literal 'external.kind.table'    (u8.const 1))
(literal 'external.kind.memory'   (u8.const 2))
(literal 'external.kind.global'   (u8.const 3))

#### Callback values.

(literal 'br_table.begin'            (u32.const 100))
(literal 'br_table.count'            (u32.const 101))
(literal 'br_table.default'          (u32.const 102))
(literal 'br_table.end'              (u32.const 103))
(literal 'br_table.target'           (u32.const 104))
(literal 'br_target.begin'           (u32.const 105))
(literal 'br_target.end'             (u32.const 106))
(literal 'code.section.begin'        (u32.const 107))
(literal 'code.section.count'        (u32.const 108))
(literal 'code.section.end'          (u32.const 109))
(literal 'data.section.begin'        (u32.const 110))
(literal 'data.section.count'        (u32.const 111))
(literal 'data.section.end'          (u32.const 112))
(literal 'data.segment.begin'        (u32.const 113))
(literal 'data.segment.memory_index' (u32.const 114))
(literal 'data.segment.size'         (u32.const 115))
(literal 'data.segment.data'         (u32.const 116))
(literal 'data.segment.end'          (u32.const 117))
(literal 'element.section.begin'     (u32.const 118))
(literal 'element.section.count'     (u32.const 119))
(literal 'element.section.end'       (u32.const 120))
(literal 'element.segment.begin'     (u32.const 121))
(literal 'element.segment.index'     (u32.const 122))
(literal 'element.segment.offset'    (u32.const 123))
(literal 'element.segment.num_elem'  (u32.const 124))
(literal 'element.segment.elem'      (u32.const 125))
(literal 'element.segment.end'       (u32.const 126))
(literal 'export.section.begin'      (u32.const 127))
(literal 'export.section.count'      (u32.const 128))
(literal 'export.section.end'        (u32.const 129))
(literal 'export.entry.name'         (u32.const 130))
(literal 'export.entry.index'        (u32.const 131))
(literal 'external.kind.begin'       (u32.const 132))
(literal 'external.kind.end'         (u32.const 133))
(literal 'file.begin'                (u32.const 134))
(literal 'file.end'                  (u32.const 135))
(literal 'function.section.begin'    (u32.const 136))
(literal 'function.section.count'    (u32.const 137))
(literal 'function.section.type'     (u32.const 138))
(literal 'function.section.end'      (u32.const 139))
(literal 'function.names.begin'      (u32.const 140))
(literal 'function.names.fcn_name'   (u32.const 141))
(literal 'function.names.local_count' (u32.const 142))
(literal 'function.names.local_name' (u32.const 143))
(literal 'function.names.end'        (u32.const 144))
(literal 'function.type.begin'       (u32.const 145))
(literal 'function.type.form'        (u32.const 146))
(literal 'type.num.params'           (u32.const 147))
(literal 'type.param'                (u32.const 148))
(literal 'type.num.returns'          (u32.const 149))
(literal 'type.return'               (u32.const 150))
(literal 'function.type.end'         (u32.const 151))
(literal 'function.body.begin'       (u32.const 152))
(literal 'function.body.local_count' (u32.const 153))
(literal 'function.body.code.begin'  (u32.const 154))
(literal 'function.body.code.end'    (u32.const 155))
(literal 'function.body.end'         (u32.const 156))
(literal 'global.section.begin'      (u32.const 157))
(literal 'global.section.count'      (u32.const 158))
(literal 'global.section.variable.type' (u32.const 159))
(literal 'global.section.variable.init' (u32.const 160))
(literal 'global.section.end'        (u32.const 161))
(literal 'global.type.begin'         (u32.const 162))
(literal 'global.type.end'           (u32.const 163))
(literal 'import.section.begin'      (u32.const 164))
(literal 'import.section.count'      (u32.const 165))
(literal 'import.section.end'        (u32.const 166))
(literal 'import.entry.begin'        (u32.const 167))
(literal 'import.entry.module'       (u32.const 168))
(literal 'import.entry.field'        (u32.const 169))
(literal 'import.entry.function'     (u32.const 170))
(literal 'import.entry.table'        (u32.const 171))
(literal 'import.entry.memory'       (u32.const 172))
(literal 'import.entry.global'       (u32.const 173))
(literal 'import.entry.end'          (u32.const 174))
(literal 'init_expr.begin'           (u32.const 175))
(literal 'init_expr.opcode'          (u32.const 176))
(literal 'init_expr.end'             (u32.const 177))
(literal 'instruction.opcode'        (u32.const 178))
(literal 'instruction.end'           (u32.const 179))
(literal 'local.entry'               (u32.const 180))
(literal 'local.entry.begin'         (u32.const 181))
(literal 'local.entry.count'         (u32.const 182))
(literal 'local.entry.end'           (u32.const 183))
(literal 'memory.section.begin'      (u32.const 184))
(literal 'memory.section.count'      (u32.const 185))
(literal 'memory.section.entry'      (u32.const 186))
(literal 'memory.section.end'        (u32.const 187))
(literal 'memory.immediate.begin'    (u32.const 188))
(literal 'memory.immediate.end'      (u32.const 189))
(literal 'name.section.begin'        (u32.const 190))
(literal 'name.section.count'        (u32.const 191))
(literal 'name.section.end'          (u32.const 192))
(literal 'memory.type.begin'         (u32.const 193))
(literal 'memory.type.end'           (u32.const 194))
(literal 'resizable.limits.begin'    (u32.const 195))
(literal 'resizable.limits.flags'    (u32.const 196))
(literal 'resizable.limits.initial'  (u32.const 197))
(literal 'resizable.limits.maximum'  (u32.const 198))
(literal 'resizable.limits.end'      (u32.const 199))
(literal 'section.begin'             (u32.const 200))
(literal 'section.code'              (u32.const 201))
(literal 'section.end'               (u32.const 202))
(literal 'skip.section.begin'        (u32.const 203))
(literal 'skip.section.end'          (u32.const 204))
(literal 'start.section.begin'       (u32.const 205))
(literal 'start.section.end'         (u32.const 206))
(literal 'symbol.name.length'        (u32.const 207))
(literal 'symbol.name.begin'         (u32.const 208))
(literal 'symbol.name.end'           (u32.const 209))
(literal 'table.section.begin'       (u32.const 210))
(literal 'table.section.count'       (u32.const 211))
(literal 'table.section.type'        (u32.const 212))
(literal 'table.section.end'         (u32.const 213))
(literal 'table.type.begin'          (u32.const 214))
(literal 'table.type.end'            (u32.const 215))
(literal 'type.section.begin'        (u32.const 216))
(literal 'type.section.end'          (u32.const 217))
(literal 'type.section.count'        (u32.const 218))
(literal 'type.value.begin'          (u32.const 219))
(literal 'type.value.end'            (u32.const 220))
(literal 'unknown.section.begin'     (u32.const 221))
(literal 'unknown.section.end'       (u32.const 222))
(literal 'instruction.begin'         (u32.const 223))

(define 'br_table' (params)
  (=> 'br_table.begin')
  (loop
    (seq (varuint32) (=> 'br_table.count'))
    (varuint32)
    (=> 'br_table.target'))
  (varuint32)
  (=> 'br_table.default')
  (=> 'br_table.end')
)

(define 'br_target' (params)
   (=> 'br_target.begin')
   (varuint32)
   (=> 'br_target.end')
)

(define 'code.section' (params)
  (=> 'code.section.begin')
  (loop
    (seq (varuint32) (=> 'code.section.count'))
    (eval 'function.body'))
  (=> 'code.section.end')
)

(define 'data.section' (params)
  (=> 'data.section.begin')
  (loop
    (seq (varuint32) (=> 'data.section.count'))
    (eval 'data.segment'))
  (=> 'data.section.end')
)

(define 'data.segment' (params)
  (=> 'data.segment.begin')
  (varuint32)
  (=> 'data.segment.memory_index')
  (eval 'init_expr')        # an i32 initializer defining offset to place data.
  (loop 
    (seq (varuint32) (=> 'data.segment.size'))
    (uint8)
    (=> 'data.segment.data'))
  (=> 'data.segment.end')
)

(define 'element.section' (params)
  (=> 'element.section.begin')
  (loop
    (seq (varuint32) (=> 'element.section.count'))
    (eval 'element.segment')
  )
  (=> 'element.section.end')
)

(define 'element.segment' (params)
  (=> 'element.segment.begin')
  (varuint32)                 # The table index
  (=> 'element.segment.index')
  (eval 'init_expr')         # An i32 initializer that computess the
                             # placement offset.
  (=> 'element.segment.offset')
  (loop
    (seq (varuint32) (=> 'element.segment.num_elem'))
    (varuint32)
    (=> 'element.segment.elem')
  )
  (=> 'element.segment.end')
)

(define 'export.section' (params)
  (=> 'export.section.begin')
  (loop 
    (seq (varuint32) (=> 'export.section.count'))
    (eval 'export.entry'))
  (=> 'export.section.end')
)

(define 'export.entry' (params)
  (eval 'symbol.name')       # Exported field name.
  (=> 'export.entry.name')
  (eval 'external.kind')
  (varuint32)
  (=> 'export.entry.index')
)

(define 'external.kind' (params)
  (=> 'external.kind.begin')
  (uint8)
  (=> 'external.kind.end')
)

(define 'file' (params)
  (=> 'file.begin')
  (loop.unbounded
    (eval 'section')
  )
  (=> 'file.end')
)

(define 'function.section' (params)
  (=> 'function.section.begin')
  (loop
    (seq (varuint32) (=> 'function.section.count'))
    (varuint32)
    (=> 'function.section.type')
  )
  (=> 'function.section.end')
)

(define 'function.names' (params)
  (=> 'function.names.begin')
  (eval 'symbol.name')       # function name
  (=> 'function.names.fcn_name')
  (loop
    (seq (varuint32) (=> 'function.names.local_count'))
    (eval 'symbol.name')
    (=> 'function.names.local_name')
  )
  (=> 'function.names.end')
)

(define 'function.type' (params)
  (=> 'function.type.begin')
  (varint32)  # type form
  (=> 'function.type.form')
  (loop
    (seq (varuint32) (=> 'type.num.params'))
    (eval 'type.value')
    (=> 'type.param')
  )
  (loop
    (seq (varuint32) (=> 'type.num.returns'))
    (eval 'type.value')
    (=> 'type.return')
  )
  (=> 'function.type.end')
)

(define 'function.body' (params)
  (=> 'function.body.begin')
  (block
    (loop
      (seq (varuint32) (=> 'function.body.local_count'))
      (eval 'local.entry'))
    (=> 'function.body.code.begin')
    (loop.unbounded
      (eval 'instruction.opcode')     # reads instruction opcode
      (eval 'instruction'))      # selects/parses corresponding instruction.
    (=> 'function.body.code.end')
  )
  (=> 'function.body.end')
)

(define 'global.section' (params)
  (=> 'global.section.begin')
  (loop
    (seq (varuint32) (=> 'global.section.count'))
    (eval 'global.type')
    (=> 'global.section.variable.type')
    (eval 'init_expr')
    (=> 'global.section.variable.init')
  )
  (=> 'global.section.end')
)

(define 'global.type' (params)
  (=> 'global.type.begin')
  (eval 'type.value')
  (uint8)
  (=> 'global.type.end')
)

(define 'import.section' (params)
  (=> 'import.section.begin')
  (loop 
    (seq (varuint32) (=> 'import.section.count'))
    (eval 'import.entry')
  )
  (=> 'import.section.end')
)

(define 'import.entry' (params)
  (=> 'import.entry.begin')
  (eval 'symbol.name')
  (=> 'import.entry.module')
  (eval 'symbol.name')
  (=> 'import.entry.field')
  (switch (eval 'external.kind')
    (error)
    (case 'external.kind.function'
      (varuint32)
      (=> 'import.entry.function'))
    (case 'external.kind.table'
      (eval 'table.type')
      (=> 'import.entry.table'))
    (case 'external.kind.memory'
      (eval 'memory.type')
      (=> 'import.entry.memory'))
    (case 'external.kind.global'
      (eval 'global.type')
      (=> 'import.entry.global'))
  )
  (=> 'import.entry.end')
)

(define 'init_expr' (params)
  (locals 1)
  (=> 'init_expr.begin')
  (set (local 0) (u32.const 1))
  (eval 'instruction.opcode')      # Opcode of expression.
  (switch (seq (read) (=> 'init_expr.opcode'))
    (error)                 # Only allows explicitly allowed operands.
    (case 'inst.i32.const'
      (varint32)
      (=> 'inst.i32.const'))
    (case 'inst.i64.const'
      (varint64)
      (=> 'inst.i64.const'))
    (case 'inst.f32.const'
      (uint32)
      (=> 'inst.f32.const'))
    (case 'inst.f64.const'
      (uint64)
      (=> 'inst.f64.const'))
    (case 'inst.get_global'
      (varuint32)
      (=> 'inst.get_global'))
    (case 'inst.end'
      (=> 'inst.end')
      (set (local 0) (u32.const 0)))
  )
  (if (local 0)
    (switch (eval 'instruction.opcode')
      (error)
      (case 'inst.end' (=> 'inst.end'))
    )
  )
  (=> 'init_expr.end')
)

(define 'instruction' (params)
  (=> 'instruction.begin')
  (switch (seq (read) (=> 'instruction.opcode'))
    (error)
    # control flow operators.
    (case 'inst.unreachable' (=> 'inst.unreachable'))
    (case 'inst.nop' (=> 'inst.nop'))
    (case 'inst.block'
      (eval 'type.value')
      (=> 'inst.block'))
    (case 'inst.loop'
      (eval 'type.value')
      (=> 'inst.loop'))
    (case 'inst.if'
      (eval 'type.value')
      (=> 'inst.if'))
    (case 'inst.else' (=> 'inst.else'))
    (case 'inst.end' (=> 'inst.end'))
    (case 'inst.br'
      (eval 'br_target')
      (=> 'inst.br'))
    (case 'inst.br_if'
      (eval 'br_target')
      (=> 'inst.br_if'))
    (case 'inst.br_table'
      (eval 'br_table')
      (=> 'inst.br_table'))
    (case 'inst.return'
      (=> 'inst.return'))

    # Call operators.
    (case 'inst.call'
      (varuint32) # function index
      (=> 'inst.call'))
    (case 'inst.call_indirect'
      (varuint32) # function index
      (varuint32) # reserved
      (=> 'inst.call_indirect'))

    # Parametric operators
    (case 'inst.drop'
      (=> 'inst.drop'))
    (case 'inst.select'
      (=> 'inst.select'))

    # Variable access
    (case 'inst.get_local'
      (varuint32)
      (=> 'inst.get_local'))
    (case 'inst.set_local'
      (varuint32)
      (=> 'inst.set_local'))
    (case 'inst.tee_local'
      (varuint32)
      (=> 'inst.tee_local'))
    (case 'inst.get_global'
      (varuint32)
      (=> 'inst.get_global'))
    (case 'inst.set_global'
      (varuint32)
      (=> 'inst.set_global'))

    # Memory-related operators
    (case 'inst.i32.load'
      (eval 'memory.immediate')
      (=> 'inst.i32.load'))
    (case 'inst.i64.load'
      (eval 'memory.immediate')
      (=> 'inst.i64.load'))
    (case 'inst.f32.load'
      (eval 'memory.immediate')
      (=> 'inst.f32.load'))
    (case 'inst.f64.load'
      (eval 'memory.immediate')
      (=> 'inst.f64.load'))
    (case 'inst.i32.load8_s'
      (eval 'memory.immediate')
      (=> 'inst.i32.load8_s'))
    (case 'inst.i32.load8_u'
      (eval 'memory.immediate')
      (=> 'inst.i32.load8_u'))
    (case 'inst.i32.load16_s'
      (eval 'memory.immediate')
      (=> 'inst.i32.load16_s'))
    (case 'inst.i32.load16_u'
      (eval 'memory.immediate')
      (=> 'inst.i32.load16_u'))
    (case 'inst.i64.load8_s'
      (eval 'memory.immediate')
      (=> 'inst.i64.load8_s'))
    (case 'inst.i64.load8_u'
      (eval 'memory.immediate')
      (=> 'inst.i64.load8_u'))
    (case 'inst.i64.load16_s'
      (eval 'memory.immediate')
      (=> 'inst.i64.load16_s'))
    (case 'inst.i64.load16_u'
      (eval 'memory.immediate')
      (=> 'inst.i64.load16_u'))
    (case 'inst.i64.load32_s'
      (eval 'memory.immediate')
      (=> 'inst.i64.load32_s'))
    (case 'inst.i64.load32_u'
      (eval 'memory.immediate')
      (=> 'inst.i64.load32_u'))
    (case 'inst.i32.store'
      (eval 'memory.immediate')
      (=> 'inst.i32.store'))
    (case 'inst.i64.store'
      (eval 'memory.immediate')
      (=> 'inst.i64.store'))
    (case 'inst.f32.store'
      (eval 'memory.immediate')
      (=> 'inst.f32.store'))
    (case 'inst.f64.store'
      (eval 'memory.immediate')
      (=> 'inst.f64.store'))
    (case 'inst.i32.store8'
      (eval 'memory.immediate')
      (=> 'inst.i32.store8'))
    (case 'inst.i32.store16'
      (eval 'memory.immediate')
      (=> 'inst.i32.store16'))
    (case 'inst.i64.store8'
      (eval 'memory.immediate')
      (=> 'inst.i64.store8'))
    (case 'inst.i64.store16'
      (eval 'memory.immediate')
      (=> 'inst.i64.store16'))
    (case 'inst.i64.store32'
      (eval 'memory.immediate')
      (=> 'inst.i64.store32'))
    (case 'inst.current_memory'
      (varuint32)
      (=> 'inst.current_memory'))
    (case 'inst.grow_memory'
      (varuint32)
      (=> 'inst.grow_memory'))

    # Constants
    (case 'inst.i32.const'
      (varint32)
      (=> 'inst.i32.const'))
    (case 'inst.i64.const'
      (varint64)
      (=> 'inst.i64.const'))
    (case 'inst.f32.const'
      (uint32)
      (=> 'inst.f32.const'))
    (case 'inst.f64.const'
      (uint64)
      (=> 'inst.f64.const'))

    # Comparison operators
    (case 'inst.i32.eqz'  (=> 'inst.i32.eqz'))
    (case 'inst.i32.eq'   (=> 'inst.i32.eq'))
    (case 'inst.i32.ne'   (=> 'inst.i32.ne'))
    (case 'inst.i32.lt_s' (=> 'inst.i32.lt_s'))
    (case 'inst.i32.lt_u' (=> 'inst.i32.lt_u'))
    (case 'inst.i32.gt_s' (=> 'inst.i32.gt_s'))
    (case 'inst.i32.gt_u' (=> 'inst.i32.gt_u'))
    (case 'inst.i32.le_s' (=> 'inst.i32.le_s'))
    (case 'inst.i32.le_u' (=> 'inst.i32.le_u'))
    (case 'inst.i32.ge_s' (=> 'inst.i32.ge_s'))
    (case 'inst.i32.ge_u' (=> 'inst.i32.ge_u'))
    (case 'inst.i64.eqz'  (=> 'inst.i64.eqz'))
    (case 'inst.i64.eq'   (=> 'inst.i64.eq'))
    (case 'inst.i64.ne'   (=> 'inst.i64.ne'))
    (case 'inst.i64.lt_s' (=> 'inst.i64.lt_s'))
    (case 'inst.i64.lt_u' (=> 'inst.i64.lt_u'))
    (case 'inst.i64.gt_s' (=> 'inst.i64.gt_s'))
    (case 'inst.i64.gt_u' (=> 'inst.i64.gt_u'))
    (case 'inst.i64.le_s' (=> 'inst.i64.le_s'))
    (case 'inst.i64.le_u' (=> 'inst.i64.le_u'))
    (case 'inst.i64.ge_s' (=> 'inst.i64.ge_s'))
    (case 'inst.i64.ge_u' (=> 'inst.i64.ge_u'))
    (case 'inst.f32.eq'   (=> 'inst.f32.eq'))
    (case 'inst.f32.ne'   (=> 'inst.f32.ne'))
    (case 'inst.f32.lt'   (=> 'inst.f32.lt'))
    (case 'inst.f32.gt'   (=> 'inst.f32.gt'))
    (case 'inst.f32.le'   (=> 'inst.f32.le'))
    (case 'inst.f32.ge'   (=> 'inst.f32.ge'))
    (case 'inst.f64.eq'   (=> 'inst.f64.eq'))
    (case 'inst.f64.ne'   (=> 'inst.f64.ne'))
    (case 'inst.f64.lt'   (=> 'inst.f64.lt'))
    (case 'inst.f64.gt'   (=> 'inst.f64.gt'))
    (case 'inst.f64.le'   (=> 'inst.f64.le'))
    (case 'inst.f64.ge'   (=> 'inst.f64.ge'))

    # Numeric operators
    (case 'inst.i32.clz'      (=> 'inst.i32.clz'))
    (case 'inst.i32.ctx'      (=> 'inst.i32.ctx'))
    (case 'inst.i32.popcnt'   (=> 'inst.i32.popcnt'))
    (case 'inst.i32.add'      (=> 'inst.i32.add'))
    (case 'inst.i32.sub'      (=> 'inst.i32.sub'))
    (case 'inst.i32.mul'      (=> 'inst.i32.mul'))
    (case 'inst.i32.div_s'    (=> 'inst.i32.div_s'))
    (case 'inst.i32.div_u'    (=> 'inst.i32.div_u'))
    (case 'inst.i32.rem_s'    (=> 'inst.i32.rem_s'))
    (case 'inst.i32.rem_u'    (=> 'inst.i32.rem_u'))
    (case 'inst.i32.and'      (=> 'inst.i32.and'))
    (case 'inst.i32.or'       (=> 'inst.i32.or'))
    (case 'inst.i32.xor'      (=> 'inst.i32.xor'))
    (case 'inst.i32.shl'      (=> 'inst.i32.shl'))
    (case 'inst.i32.shr_s'    (=> 'inst.i32.shr_s'))
    (case 'inst.i32.shr_u'    (=> 'inst.i32.shr_u'))
    (case 'inst.i32.rotl'     (=> 'inst.i32.rotl'))
    (case 'inst.i32.rotr'     (=> 'inst.i32.rotr'))
    (case 'inst.i64.clz'      (=> 'inst.i64.clz'))
    (case 'inst.i64.ctx'      (=> 'inst.i64.ctx'))
    (case 'inst.i64.popcnt'   (=> 'inst.i64.popcnt'))
    (case 'inst.i64.add'      (=> 'inst.i64.add'))
    (case 'inst.i64.sub'      (=> 'inst.i64.sub'))
    (case 'inst.i64.mul'      (=> 'inst.i64.mul'))
    (case 'inst.i64.div_s'    (=> 'inst.i64.div_s'))
    (case 'inst.i64.div_u'    (=> 'inst.i64.div_u'))
    (case 'inst.i64.rem_s'    (=> 'inst.i64.rem_s'))
    (case 'inst.i64.rem_u'    (=> 'inst.i64.rem_u'))
    (case 'inst.i64.and'      (=> 'inst.i64.and'))
    (case 'inst.i64.or'       (=> 'inst.i64.or'))
    (case 'inst.i64.xor'      (=> 'inst.i64.xor'))
    (case 'inst.i64.shl'      (=> 'inst.i64.shl'))
    (case 'inst.i64.shr_s'    (=> 'inst.i64.shr_s'))
    (case 'inst.i64.shr_u'    (=> 'inst.i64.shr_u'))
    (case 'inst.i64.rotl'     (=> 'inst.i64.rotl'))
    (case 'inst.i64.rotr'     (=> 'inst.i64.rotr'))
    (case 'inst.f32.abs'      (=> 'inst.f32.abs'))
    (case 'inst.f32.neg'      (=> 'inst.f32.neg'))
    (case 'inst.f32.ceil'     (=> 'inst.f32.ceil'))
    (case 'inst.f32.floor'    (=> 'inst.f32.floor'))
    (case 'inst.f32.trunc'    (=> 'inst.f32.trunc'))
    (case 'inst.f32.nearest'  (=> 'inst.f32.nearest'))
    (case 'inst.f32.sqrt'     (=> 'inst.f32.sqrt'))
    (case 'inst.f32.add'      (=> 'inst.f32.add'))
    (case 'inst.f32.sub'      (=> 'inst.f32.sub'))
    (case 'inst.f32.mul'      (=> 'inst.f32.mul'))
    (case 'inst.f32.div'      (=> 'inst.f32.div'))
    (case 'inst.f32.min'      (=> 'inst.f32.min'))
    (case 'inst.f32.max'      (=> 'inst.f32.max'))
    (case 'inst.f32.copysign' (=> 'inst.f32.copysign'))
    (case 'inst.f64.abs'      (=> 'inst.f64.abs'))
    (case 'inst.f64.neg'      (=> 'inst.f64.neg'))
    (case 'inst.f64.ceil'     (=> 'inst.f64.ceil'))
    (case 'inst.f64.floor'    (=> 'inst.f64.floor'))
    (case 'inst.f64.trunc'    (=> 'inst.f64.trunc'))
    (case 'inst.f64.nearest'  (=> 'inst.f64.nearest'))
    (case 'inst.f64.sqrt'     (=> 'inst.f64.sqrt'))
    (case 'inst.f64.add'      (=> 'inst.f64.add'))
    (case 'inst.f64.sub'      (=> 'inst.f64.sub'))
    (case 'inst.f64.mul'      (=> 'inst.f64.mul'))
    (case 'inst.f64.div'      (=> 'inst.f64.div'))
    (case 'inst.f64.min'      (=> 'inst.f64.min'))
    (case 'inst.f64.max'      (=> 'inst.f64.max'))
    (case 'inst.f64.copysign' (=> 'inst.f64.copysign'))

    # Conversions
    (case 'inst.i32.wrap/i64'      (=> 'inst.i32.wrap/i64'))
    (case 'inst.i32.trunc_s/f32'   (=> 'inst.i32.trunc_s/f32'))
    (case 'inst.i32.trunc_u/f32'   (=> 'inst.i32.trunc_u/f32'))
    (case 'inst.i32.trunc_s/f64'   (=> 'inst.i32.trunc_s/f64'))
    (case 'inst.i32.trunc_u/f64'   (=> 'inst.i32.trunc_u/f64'))
    (case 'inst.i64.extend_s/i32'  (=> 'inst.i64.extend_s/i32'))
    (case 'inst.i64.extend_u/i32'  (=> 'inst.i64.extend_u/i32'))
    (case 'inst.i64.trunc_s/f32'   (=> 'inst.i64.trunc_s/f32'))
    (case 'inst.i64.trunc_u/f32'   (=> 'inst.i64.trunc_u/f32'))
    (case 'inst.i64.trunc_s/f64'   (=> 'inst.i64.trunc_s/f64'))
    (case 'inst.i64.trunc_u/f64'   (=> 'inst.i64.trunc_u/f64'))
    (case 'inst.f32.convert_s/i32' (=> 'inst.f32.convert_s/i32'))
    (case 'inst.f32.convert_u/i32' (=> 'inst.f32.convert_u/i32'))
    (case 'inst.f32.convert_s/i64' (=> 'inst.f32.convert_s/i64'))
    (case 'inst.f32.convert_u/i64' (=> 'inst.f32.convert_u/i64'))
    (case 'inst.f32.demote/f64'    (=> 'inst.f32.demote/f64'))
    (case 'inst.f64.convert_s/i32' (=> 'inst.f64.convert_s/i32'))
    (case 'inst.f64.convert_u/i32' (=> 'inst.f64.convert_u/i32'))
    (case 'inst.f64.convert_s/i64' (=> 'inst.f64.convert_s/i64'))
    (case 'inst.f64.convert_u/i64' (=> 'inst.f64.convert_u/i64'))
    (case 'inst.f64.promote/f32'   (=> 'inst.f64.promote/f32'))

    # Reinterpretations
    (case 'inst.i32.reinterpret/f32' (=> 'inst.i32.reinterpret/f32'))
    (case 'inst.i64.reinterpret/f64' (=> 'inst.i64.reinterpret/f64'))
    (case 'inst.f32.reinterpret/i32' (=> 'inst.f32.reinterpret/i32'))
    (case 'inst.f64.reinterpret/i64' (=> 'inst.f64.reinterpret/i64'))
  )
  (=> 'instruction.end')
)

(define 'instruction.opcode' (params) (uint8))

(define 'local.entry' (params)
  (=> 'local.entry.begin')
  (varuint32)
  (=> 'local.entry.count')
  (eval 'type.value')
  (=> 'local.entry.end')
)

(define 'memory.section' (params)
  (=> 'memory.section.begin')
  (loop
    (seq (varuint32) (=> 'memory.section.count'))
    (eval 'memory.type')
    (=> 'memory.section.entry')
  )
  (=> 'memory.section.end')
)

(define 'memory.immediate' (params)
  (=> 'memory.immediate.begin')
  (varuint32)                  # log2 alignment/flags
  (varuint32)                  # offset
  (=> 'memory.immediate.end')
)

(define 'name.section' (params) # todo: fix.
  (=> 'name.section.begin')
  (loop
    (seq (varuint32) (=> 'name.section.count'))
    (eval 'function.names'))
  (=> 'name.section.end')
)

(define 'memory.type' (params)
  (=> 'memory.type.begin')
  (eval 'resizable.limits')
  (=> 'memory.type.end')
)

(define 'resizable.limits' (params)
  (locals 1)
  (=> 'resizable.limits.begin')
  (set (local 0) (varuint32))
  (=> 'resizable.limits.flags')
  (varuint32)
  (=> 'resizable.limits.initial')
  (if (bitwise.and (local 0) (u32.const 0x1))
    (seq
      (varuint32)
      (=> 'resizable.limits.maximum')
    )
  )
  (=> 'resizable.limits.end')
)

(define 'section' (params)
  (locals 1)
  (=> 'section.begin')
  (set (local 0) (varuint32))
  (=> 'section.code')
  (block
    (switch (local 0)
      (error)
      (case 'unknown.section' (eval 'unknown.section'))
      (case 'type.section' (eval 'type.section'))
      (case 'import.section' (eval 'import.section'))
      (case 'function.section' (eval 'function.section'))
      (case 'table.section' (eval 'table.section'))
      (case 'memory.section' (eval 'memory.section'))
      (case 'global.section' (eval 'global.section'))
      (case 'export.section' (eval 'export.section'))
      (case 'start.section' (eval 'start.section'))
      (case 'element.section' (eval 'element.section'))
      (case 'code.section' (eval 'code.section'))
      (case 'data.section' (eval 'data.section'))
    )
  )
  (=> 'section.end')
)

(define 'skip.section' (params)
  (=> 'skip.section.begin')
  (loop.unbounded (uint8))
  (=> 'skip.section.end')
)

(define 'start.section' (params)
  (=> 'start.section.begin')
  (varuint32)
  (=> 'start.section.end')
)

(define 'symbol.name' (params)
  # Note: This define is understood by the reader. (TODO: karlschimpf)
  (=> 'symbol.name.begin')
  (loop
    (seq (varuint32) (=> 'symbol.name.length'))
    (uint8))
  (=> 'symbol.name.end')
)

(define 'table.section' (params)
  (=> 'table.section.begin')
  (loop
    (seq (varuint32) (=> 'table.section.count'))
    (eval 'table.type')
    (=> 'table.section.type')
  )
  (=> 'table.section.end')
) 

(define 'table.type' (params)
  (=> 'table.type.begin')
  (eval 'type.value')
  (eval 'resizable.limits')
  (=> 'table.type.end')
)

(define 'type.section' (params)
  (=> 'type.section.begin')
  (loop (seq (varuint32) (=> 'type.section.count'))
    (eval 'function.type')
  )
  (=> 'type.section.end')
)

(define 'type.value' (params)
  (=> 'type.value.begin')
  (varint32)
  (=> 'type.value.end')
)

(define 'unknown.section' (params)
  (=> 'unknown.section.begin')
  (eval 'symbol.name')
  (eval 'unknown_body')
  (=> 'unknown.section.end')
)

(define 'unknown_body' (params)
  (if (last.symbol.is 'name')
    (eval 'name.section')
    (eval 'skip.section')
  )
)

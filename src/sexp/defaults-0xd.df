# Copyright 2015 WebAssembly Community Group participants
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


# This file defines the default algorithms for decompressing a WASM
# module, version 0xC.

(wasm.version 0xd)
(casm.version 0x0)

(literal 'inst.unreachable'         (u8.const 0x00))
(literal 'inst.nop'                 (u8.const 0x01))
(literal 'inst.block'               (u8.const 0x02))
(literal 'inst.loop'                (u8.const 0x03))
(literal 'inst.if'                  (u8.const 0x04))
(literal 'inst.else'                (u8.const 0x05))
(literal 'inst.end'                 (u8.const 0x0b))
(literal 'inst.br'                  (u8.const 0x0c))
(literal 'inst.br_if'               (u8.const 0x0d))
(literal 'inst.br_table'            (u8.const 0x0e))
(literal 'inst.return'              (u8.const 0x0f))
(literal 'inst.call'                (u8.const 0x10))
(literal 'inst.call_indirect'       (u8.const 0x11))
(literal 'inst.drop'                (u8.const 0x1a))
(literal 'inst.select'              (u8.const 0x1b))
(literal 'inst.get_local'           (u8.const 0x20))
(literal 'inst.set_local'           (u8.const 0x21))
(literal 'inst.tee_local'           (u8.const 0x22))
(literal 'inst.get_global'          (u8.const 0x23))
(literal 'inst.set_global'          (u8.const 0x24))
(literal 'inst.i32_load'            (u8.const 0x28))
(literal 'inst.i64_load'            (u8.const 0x29))
(literal 'inst.f32_load'            (u8.const 0x2a))
(literal 'inst.f64_load'            (u8.const 0x2b))
(literal 'inst.i32.load8_s'         (u8.const 0x2c))
(literal 'inst.i32.load8_u'         (u8.const 0x2d))
(literal 'inst.i32.load16_s'        (u8.const 0x2e))
(literal 'inst.i32.load16_u'        (u8.const 0x2f))
(literal 'inst.i64.load8_s'         (u8.const 0x30))
(literal 'inst.i64.load8_u'         (u8.const 0x31))
(literal 'inst.i64.load16_s'        (u8.const 0x32))
(literal 'inst.i64.load16_u'        (u8.const 0x33))
(literal 'inst.i64.load32_s'        (u8.const 0x34))
(literal 'inst.i64.load32_u'        (u8.const 0x35))
(literal 'inst.i32.store'           (u8.const 0x36))
(literal 'inst.i64.store'           (u8.const 0x37))
(literal 'inst.f32.store'           (u8.const 0x38))
(literal 'inst.f64.store'           (u8.const 0x39))
(literal 'inst.i32.store8'          (u8.const 0x3a))
(literal 'inst.i32.store16'         (u8.const 0x3b))
(literal 'inst.i64.store8'          (u8.const 0x3c))
(literal 'inst.i64.store16'         (u8.const 0x3d))
(literal 'inst.i64.store32'         (u8.const 0x3e))
(literal 'inst.current_memory'      (u8.const 0x3f))
(literal 'inst.grow_memory'         (u8.const 0x40))
(literal 'inst.i32.const'           (u8.const 0x41))
(literal 'inst.i64.const'           (u8.const 0x42))
(literal 'inst.f32.const'           (u8.const 0x43))
(literal 'inst.f64.const'           (u8.const 0x44))
(literal 'inst.i32.eqz'             (u8.const 0x45))
(literal 'inst.i32.eq'              (u8.const 0x46))
(literal 'inst.i32.ne'              (u8.const 0x47))
(literal 'inst.i32.lt_s'            (u8.const 0x48))
(literal 'inst.i32.lt_u'            (u8.const 0x49))
(literal 'inst.i32.gt_s'            (u8.const 0x4a))
(literal 'inst.i32.gt_u'            (u8.const 0x4b))
(literal 'inst.i32.le_s'            (u8.const 0x4c))
(literal 'inst.i32.le_u'            (u8.const 0x4d))
(literal 'inst.i32.ge_s'            (u8.const 0x4e))
(literal 'inst.i32.ge_u'            (u8.const 0x4f))
(literal 'inst.i64.eqz'             (u8.const 0x50))
(literal 'inst.i64.eq'              (u8.const 0x51))
(literal 'inst.i64.ne'              (u8.const 0x52))
(literal 'inst.i64.lt_s'            (u8.const 0x53))
(literal 'inst.i64.lt_u'            (u8.const 0x54))
(literal 'inst.i64.gt_s'            (u8.const 0x55))
(literal 'inst.i64.gt_u'            (u8.const 0x56))
(literal 'inst.i64.le_s'            (u8.const 0x57))
(literal 'inst.i64.le_u'            (u8.const 0x58))
(literal 'inst.i64.ge_s'            (u8.const 0x59))
(literal 'inst.i64.ge_u'            (u8.const 0x5a))
(literal 'inst.f32.eq'              (u8.const 0x5b))
(literal 'inst.f32.ne'              (u8.const 0x5c))
(literal 'inst.f32.lt'              (u8.const 0x5d))
(literal 'inst.f32.gt'              (u8.const 0x5e))
(literal 'inst.f32.le'              (u8.const 0x5f))
(literal 'inst.f32.ge'              (u8.const 0x60))
(literal 'inst.f64.eq'              (u8.const 0x61))
(literal 'inst.f64.ne'              (u8.const 0x62))
(literal 'inst.f64.lt'              (u8.const 0x63))
(literal 'inst.f64.gt'              (u8.const 0x64))
(literal 'inst.f64.le'              (u8.const 0x65))
(literal 'inst.f64.ge'              (u8.const 0x66))
(literal 'inst.i32.clz'             (u8.const 0x67))
(literal 'inst.i32.ctx'             (u8.const 0x68))
(literal 'inst.i32.popcnt'          (u8.const 0x69))
(literal 'inst.i32.add'             (u8.const 0x6a))
(literal 'inst.i32.sub'             (u8.const 0x6b))
(literal 'inst.i32.mul'             (u8.const 0x6c))
(literal 'inst.i32.div_s'           (u8.const 0x6d))
(literal 'inst.i32.div_u'           (u8.const 0x6e))
(literal 'inst.i32.rem_s'           (u8.const 0x6f))
(literal 'inst.i32.rem_u'           (u8.const 0x70))
(literal 'inst.i32.and'             (u8.const 0x71))
(literal 'inst.i32.or'              (u8.const 0x72))
(literal 'inst.i32.xor'             (u8.const 0x73))
(literal 'inst.i32.shl'             (u8.const 0x74))
(literal 'inst.i32.shr_s'           (u8.const 0x75))
(literal 'inst.i32.shr_u'           (u8.const 0x76))
(literal 'inst.i32.rotl'            (u8.const 0x77))
(literal 'inst.i32.rotr'            (u8.const 0x78))
(literal 'inst.i64.clz'             (u8.const 0x79))
(literal 'inst.i64.ctz'             (u8.const 0x7a))
(literal 'inst.i64.popcnt'          (u8.const 0x7b))
(literal 'inst.i64.add'             (u8.const 0x7c))
(literal 'inst.i64.sub'             (u8.const 0x7d))
(literal 'inst.i64.mul'             (u8.const 0x7e))
(literal 'inst.i64.div_s'           (u8.const 0x7f))
(literal 'inst.i64.div_u'           (u8.const 0x80))
(literal 'inst.i64.rem_s'           (u8.const 0x81))
(literal 'inst.i64.rem_u'           (u8.const 0x82))
(literal 'inst.i64.and'             (u8.const 0x83))
(literal 'inst.i64.or'              (u8.const 0x84))
(literal 'inst.i64.xor'             (u8.const 0x85))
(literal 'inst.i64.shl'             (u8.const 0x86))
(literal 'inst.i64.shr_s'           (u8.const 0x87))
(literal 'inst.i64.shr_u'           (u8.const 0x88))
(literal 'inst.i64.rotl'            (u8.const 0x89))
(literal 'inst.i64.rotr'            (u8.const 0x8a))
(literal 'inst.f32.abs'             (u8.const 0x8b))
(literal 'inst.f32.neg'             (u8.const 0x8c))
(literal 'inst.f32.ceil'            (u8.const 0x8d))
(literal 'inst.f32.floor'           (u8.const 0x8e))
(literal 'inst.f32.trunc'           (u8.const 0x8f))
(literal 'inst.f32.nearest'         (u8.const 0x90))
(literal 'inst.f32.sqrt'            (u8.const 0x91))
(literal 'inst.f32.add'             (u8.const 0x92))
(literal 'inst.f32.sub'             (u8.const 0x93))
(literal 'inst.f32.mul'             (u8.const 0x94))
(literal 'inst.f32.div'             (u8.const 0x95))
(literal 'inst.f32.min'             (u8.const 0x96))
(literal 'inst.f32.max'             (u8.const 0x97))
(literal 'inst.f32.copysign'        (u8.const 0x98))
(literal 'inst.f64.abs'             (u8.const 0x99))
(literal 'inst.f64.neg'             (u8.const 0x9a))
(literal 'inst.f64.ceil'            (u8.const 0x9b))
(literal 'inst.f64.floor'           (u8.const 0x9c))
(literal 'inst.f64.trunc'           (u8.const 0x9d))
(literal 'inst.f64.nearest'         (u8.const 0x9e))
(literal 'inst.f64.sqrt'            (u8.const 0x9f))
(literal 'inst.f64.add'             (u8.const 0xa0))
(literal 'inst.f64.sub'             (u8.const 0xa1))
(literal 'inst.f64.mul'             (u8.const 0xa2))
(literal 'inst.f64.div'             (u8.const 0xa3))
(literal 'inst.f64.min'             (u8.const 0xa4))
(literal 'inst.f64.max'             (u8.const 0xa5))
(literal 'inst.f64.copysign'        (u8.const 0xa6))
(literal 'inst.i32.wrap/i64'        (u8.const 0xa7))
(literal 'inst.i32.trunc_s/f32'     (u8.const 0xa8))
(literal 'inst.i32.trunc_u/f32'     (u8.const 0xa9))
(literal 'inst.i32.trunc_s/f64'     (u8.const 0xaa))
(literal 'inst.i32.trunc_s/f64'     (u8.const 0xab))
(literal 'inst.i64.extend_s/i32'    (u8.const 0xac))
(literal 'inst.i64.extend_u/i32'    (u8.const 0xad))
(literal 'inst.i64.trunc_s/f32'     (u8.const 0xae))
(literal 'inst.i64.trunc_u/f32'     (u8.const 0xaf))
(literal 'inst.i64.trunc_s/f64'     (u8.const 0xb0))
(literal 'inst.i64.trunc_u/f64'     (u8.const 0xb1))
(literal 'inst.f32.convert_s/i32'   (u8.const 0xb2))
(literal 'inst.f32.convert_u/i32'   (u8.const 0xb3))
(literal 'inst.f32.convert_s/i64'   (u8.const 0xb4))
(literal 'inst.f32.convert_u/i64'   (u8.const 0xb5))
(literal 'inst.f32.demote/f64'      (u8.const 0xb6))
(literal 'inst.f64.convert_s/i32'   (u8.const 0xb7))
(literal 'inst.f64.convert_u/i32'   (u8.const 0xb8))
(literal 'inst.f64.convert_s/i64'   (u8.const 0xb9))
(literal 'inst.f64.convert_u/i64'   (u8.const 0xba))
(literal 'inst.f64.promote/f32'     (u8.const 0xbb))
(literal 'inst.i32.reinterpret/f32' (u8.const 0xbc))
(literal 'inst.i64.reinterpret/f64' (u8.const 0xbd))
(literal 'inst.f32.reinterpret/i32' (u8.const 0xbe))
(literal 'inst.ft4.reinterpret/i64' (u8.const 0xbf))

(literal 'unknown.section'  (u32.const 0))
(literal 'type.section'     (u32.const 1))
(literal 'import.section'   (u32.const 2))
(literal 'function.section' (u32.const 3))
(literal 'table.section'    (u32.const 4))
(literal 'memory.section'   (u32.const 5))
(literal 'global.section'   (u32.const 6))
(literal 'export.section'   (u32.const 7))
(literal 'start.section'    (u32.const 8))
(literal 'element.section'  (u32.const 9))
(literal 'code.section'     (u32.const 10))
(literal 'data.section'     (u32.const 11))

(literal 'external_kind.function' (u8.const 0))
(literal 'external_kind.table'    (u8.const 1))
(literal 'external_kind.memory'   (u8.const 2))
(literal 'external_kind.global'   (u8.const 3))

(define 'br_table' (params)
  (=> 'br_table.begin')
  (loop
    (seq (varuint32) (=> 'br_table.count'))
    (varuint32)
    (=> 'br_table.target'))
  (varuint32)
  (=> 'br_table.default')
  (=> 'br_table.end')
)

(define 'br_target' (params)
   (=> 'br_target.begin')
   (varuint32)
   (=> 'br_target.end')
)

(define 'code.section' (params)
  (=> 'code.section.begin')
  (loop
    (seq (varuint32) (=> 'code.section.count'))
    (eval 'function_body'))
  (=> 'code.section.end')
)

(define 'data.section' (params)
  (=> 'data.section.begin')
  (loop
    (seq (varuint32) (=> 'data.section.count'))
    (eval 'data_segment'))
  (=> 'data.section.end')
)

(define 'data_segment' (params)
  (=> 'data_segment.begin')
  (varuint32)
  (=> 'data_segment.memory_index')
  (eval 'init_expr')        # an i32 initializer defining offset to place data.
  (loop 
    (seq (varuint32) (=> 'data_segment.size'))
    (uint8)
    (=> 'data_segment.data'))
  (=> 'data_segment.end')
)

(define 'element.section' (params)
  (=> 'element.section.begin')
  (loop
    (seq (varuint32) (=> 'element.section.count'))
    (eval 'element_segment')
  )
  (=> 'element.section.end')
)

(define 'element_segment' (params)
  (=> 'element_segment.begin')
  (varuint32)                 # The table index
  (=> 'element_segment.index')
  (eval 'init_expr')         # An i32 initializer that computess the
                             # placement offset.
  (=> 'element_segment.offset')
  (loop
    (seq (varuint32) (=> 'element_segment.num_elem'))
    (varuint32)
    (=> 'element_segment.elem')
  )
  (=> 'element_segment.end')
)

(define 'export.section' (params)
  (=> 'export.section.begin')
  (loop 
    (seq (varuint32) (=> 'export.section.count'))
    (eval 'export.entry'))
  (=> 'export.section.end')
)

(define 'export.entry' (params)
  (eval 'symbol_name')       # Exported field name.
  (=> 'export.entry.name')
  (eval 'external_kind')
  (varuint32)
  (=> 'export.entry.index')
)

(define 'external_kind' (params)
  (=> 'external_kind.begin')
  (uint8)
  (=> 'external_kind.end')
)

(define 'function.section' (params)
  (=> 'function.section.begin')
  (loop
    (seq (varuint32) (=> 'function.section.count'))
    (varuint32)
    (=> 'function.section.type')
  )
  (=> 'function.section.end')
)

(define 'function_names' (params)
  (=> 'function_names.begin')
  (eval 'symbol_name')       # function name
  (=> 'function_names.fcn_name')
  (loop
    (seq (varuint32) (=> 'function_names.local_count'))
    (eval 'symbol_name')
    (=> 'function_names.local_name')
  )
  (=> 'function_names.end')
)

(define 'function_type' (params)
  (=> 'function_type.begin')
  (varint32)  # type form
  (=> 'function_type.form')
  (loop
    (seq (varuint32) (=> 'type.num.params'))
    (eval 'type.value')
    (=> 'type.param')
  )
  (loop
    (seq (varuint32) (=> 'type.num.returns'))
    (eval 'type.value')
    (=> 'type.return')
  )
  (=> 'function_type.end')
)

(define 'function_body' (params)
  (=> 'function_body.begin')
  (block
    (loop
      (seq (varuint32) (=> 'function_body.local_count'))
      (eval 'local_entry'))
    (=> 'function_body.code.begin')
    (loop.unbounded
      (eval 'instruction.opcode')     # reads instruction opcode
      (eval 'instruction'))      # selects/parses corresponding instruction.
    (=> 'function_body.code.end')
  )
  (=> 'function_body.end')
)

(define 'global.section' (params)
  (=> 'global.section.begin')
  (loop
    (seq (varuint32) (=> 'global.section.count'))
    (eval 'global_type')
    (=> 'global.section.variable.type')
    (eval 'init_expr')
    (=> 'global.section.variable.init')
  )
  (=> 'global.section.end')
)

(define 'global_type' (params)
  (=> 'global_type.begin')
  (eval 'type.value')
  (uint8)
  (=> 'global_type.end')
)

(define 'import.section' (params)
  (=> 'import.section.begin')
  (loop 
    (seq (varuint32) (=> 'import.section.count'))
    (eval 'import_entry')
  )
  (=> 'import.section.end')
)


(define 'import_entry' (params)
  (=> 'import_entry.begin')
  (eval 'symbol_name')
  (=> 'import_entry.module')
  (eval 'symbol_name')
  (=> 'import_entry.field')
  (switch (eval 'external_kind')
    (error)
    (case 'external_kind.function'
      (varuint32)
      (=> 'import_entry.function'))
    (case 'external_kind.table'
      (eval 'table_type')
      (=> 'import_entry.table'))
    (case 'external_kind.memory'
      (eval 'memory_type')
      (=> 'import_entry.memory'))
    (case 'external_kind.global'
      (eval 'global_type')
      (=> 'import_entry.global'))
  )
  (=> 'import_entry.end')
)

(define 'init_expr' (params)
  (locals 1)
  (=> 'init_expr.begin')
  (set (local 0) (u32.const 1))
  (eval 'instruction.opcode')      # Opcode of expression.
  (switch (seq (read) (=> 'init_expr.opcode'))
    (error)                 # Only allows explicitly allowed operands.
    (case 'inst.i32.const'
      (varint32)
      (=> 'inst.i32.const'))
    (case 'inst.i64.const'
      (varint64)
      (=> 'inst.i64.const'))
    (case 'inst.f32.const'
      (uint32)
      (=> 'inst.f32.const'))
    (case 'inst.f64.const'
      (uint64)
      (=> 'inst.f64.const'))
    (case 'inst.get_global'
      (varuint32)
      (=> 'inst.get_global'))
    (case 'inst.end'
      (=> 'inst.end')
      (set (local 0) (u32.const 0)))
  )
  (if (local 0)
    (switch (eval 'instruction.opcode')
      (error)
      (case 'inst.end' (=> 'inst.end'))
    )
  )
  (=> 'init_expr.end')
)

(define 'instruction' (params)
  (=> 'instruction.begin')
  (switch (seq (read) (=> 'instruction.opcode'))
    (error)
    # control flow operators.
    (case 'inst.uunreachable' (=> 'inst.unreachable'))
    (case 'inst.nop' (=> 'inst.nop'))
    (case 'inst.block'
      (eval 'type.value')
      (=> 'inst.block'))
    (case 'inst.loop'
      (eval 'type.value')
      (=> 'inst.loop'))
    (case 'inst.if'
      (eval 'type.value')
      (=> 'inst.if'))
    (case 'inst.else' (=> 'inst.else'))
    (case 'inst.end' (=> 'inst.end'))
    (case 'inst.br'
      (eval 'br_target')
      (=> 'inst.br'))
    (case 'inst.br_if'
      (eval 'br_target')
      (=> 'inst.br_if'))
    (case (u8.const 0x08)
      (eval 'br_table')
      (=> 'inst.br_table'))
    (case 'inst.return'
      (=> 'inst.return'))

    # Call operators.
    (case 'inst.call'
      (varuint32) # function index
      (=> 'inst.call'))
    (case 'inst.call_indirect'
      (varuint32) # function index
      (varuint32) # reserved
      (=> 'inst.call_indirect'))

    # Parametric operators
    (case 'inst.drop'
      (=> 'inst.drop'))
    (case 'inst.select'
      (=> 'inst.select'))

    # Variable access
    (case 'inst.get_local'
      (varuint32)
      (=> 'inst.get_local'))
    (case 'inst.set_local'
      (varuint32)
      (=> 'inst.set_local'))
    (case 'inst.tee_local'
      (varuint32)
      (=> 'inst.tee_local'))
    (case 'inst.get_global'
      (varuint32)
      (=> 'inst.get_global'))
    (case 'inst.set_global'
      (varuint32)
      (=> 'inst.set_global'))

    # Memory-related operators
    (case 'inst.i32.load'
      (eval 'memory_immediate')
      (=> 'inst.i32.load'))
    (case 'inst.i64.load'
      (eval 'memory_immediate')
      (=> 'inst.i64.load'))
    (case 'inst.f32.load'
      (eval 'memory_immediate')
      (=> 'inst.f32.load'))
    (case 'inst.f64.load'
      (eval 'memory_immediate')
      (=> 'inst.f64.load'))
    (case 'inst.i32.load8_s'
      (eval 'memory_immediate')
      (=> 'inst.i32.load8_s'))
    (case 'inst.i32.load8_u'
      (eval 'memory_immediate')
      (=> 'inst.i32.load8_u'))
    (case 'inst.i32.load16_s'
      (eval 'memory_immediate')
      (=> 'inst.i32.load16_s'))
    (case 'inst.i32.load16_u'
      (eval 'memory_immediate')
      (=> 'inst.i32.load16_u'))
    (case 'inst.i64.load8_s'
      (eval 'memory_immediate')
      (=> 'inst.i64.load8_s'))
    (case 'inst.i64.load8_u'
      (eval 'memory_immediate')
      (=> 'inst.i64.load8_u'))
    (case 'inst.i64.load16_s'
      (eval 'memory_immediate')
      (=> 'inst.i64.load16_s'))
    (case 'inst.i64.load16_u'
      (eval 'memory_immediate')
      (=> 'inst.i64.load16_u'))
    (case 'inst.i64.load32_s'
      (eval 'memory_immediate')
      (=> 'inst.i64.load32_s'))
    (case 'inst.i64.load32_u'
      (eval 'memory_immediate')
      (=> 'inst.i64.load32_u'))
    (case 'inst.i32.store'
      (eval 'memory_immediate')
      (=> 'inst.i32.store'))
    (case 'inst.i64.store'
      (eval 'memory_immediate')
      (=> 'inst.i64.store'))
    (case 'inst.f32.store'
      (eval 'memory_immediate')
      (=> 'inst.f32.store'))
    (case 'inst.f64.store'
      (eval 'memory_immediate')
      (=> 'inst.f64.store'))
    (case 'inst.i32.store8'
      (eval 'memory_immediate')
      (=> 'inst.i32.store8'))
    (case 'inst.i32.store16'
      (eval 'memory_immediate')
      (=> 'inst.i32.store16'))
    (case 'inst.i64.store8'
      (eval 'memory_immediate')
      (=> 'inst.i64.store8'))
    (case 'inst.i64.store16'
      (eval 'memory_immediate')
      (=> 'inst.i64.store16'))
    (case 'inst.i64.store32'
      (eval 'memory_immediate')
      (=> 'inst.i64.store32'))
    (case 'inst.current_memory'
      (varuint32)
      (=> 'inst.current_memory'))
    (case 'inst.grow_memory'
      (varuint32)
      (=> 'inst.grow_memory'))

    # Constants
    (case 'inst.i32.const'
      (varint32)
      (=> 'inst.i32.const'))
    (case 'inst.i64.const'
      (varint64)
      (=> 'inst.i64.const'))
    (case 'inst.f32.const'
      (uint32)
      (=> 'inst.f32.const'))
    (case 'inst.f32.const'
      (uint64)
      (=> 'inst.f32.const'))

    # Comparison operators
    (case 'inst.i32.eqz'  (=> 'inst.i32.eqz'))
    (case 'inst.i32.eq'   (=> 'inst.i32.eq'))
    (case 'inst.i32.ne'   (=> 'inst.i32.ne'))
    (case 'inst.i32.lt_s' (=> 'inst.i32.lt_s'))
    (case 'inst.i32.lt_u' (=> 'inst.i32.lt_u'))
    (case 'inst.i32.gt_s' (=> 'inst.i32.gt_s'))
    (case 'inst.i32.gt_u' (=> 'inst.i32.gt_u'))
    (case 'inst.i32.le_s' (=> 'inst.i32.le_s'))
    (case 'inst.i32.le_u' (=> 'inst.i32.le_u'))
    (case 'inst.i32.ge_s' (=> 'inst.i32.ge_s'))
    (case 'inst.i32.ge_u' (=> 'inst.i32.ge_u'))
    (case 'inst.i64.eqz'  (=> 'inst.i64.eqz'))
    (case 'inst.i64.eq'   (=> 'inst.i64.eq'))
    (case 'inst.i64.ne'   (=> 'inst.i64.ne'))
    (case 'inst.i64.lt_s' (=> 'inst.i64.lt_s'))
    (case 'inst.i64.lt_u' (=> 'inst.i64.lt_u'))
    (case 'inst.i64.gt_s' (=> 'inst.i64.gt_s'))
    (case 'inst.i64.gt_u' (=> 'inst.i64.gt_u'))
    (case 'inst.i64.le_s' (=> 'inst.i64.le_s'))
    (case 'inst.i64.le_u' (=> 'inst.i64.le_u'))
    (case 'inst.i64.ge_s' (=> 'inst.i64.ge_s'))
    (case 'inst.i64.ge_u' (=> 'inst.i64.ge_u'))
    (case 'inst.f32.eq'   (=> 'inst.f32.eq'))
    (case 'inst.f32.ne'   (=> 'inst.f32.ne'))
    (case 'inst.f32.lt'   (=> 'inst.f32.lt'))
    (case 'inst.f32.gt'   (=> 'inst.f32.gt'))
    (case 'inst.f32.le'   (=> 'inst.f32.le'))
    (case 'inst.f32.ge'   (=> 'inst.f32.ge'))
    (case 'inst.f64.eq'   (=> 'inst.f64.eq'))
    (case 'inst.f64.ne'   (=> 'inst.f64.ne'))
    (case 'inst.f64.lt'   (=> 'inst.f64.lt'))
    (case 'inst.f64.gt'   (=> 'inst.f64.gt'))
    (case 'inst.f64.le'   (=> 'inst.f64.le'))
    (case 'inst.f64.ge'   (=> 'inst.f64.ge'))

    # Numeric operators
    (case 'inst.i32.clz'      (=> 'inst.i32.clz'))
    (case 'inst.i32.ctx'      (=> 'inst.i32.ctz'))
    (case 'inst.i32.popcnt'   (=> 'inst.i32.popcnt'))
    (case 'inst.i32.add'      (=> 'inst.i32.add'))
    (case 'inst.i32.sub'      (=> 'inst.i32.sub'))
    (case 'inst.i32.mul'      (=> 'inst.i32.mul'))
    (case 'inst.i32.div_s'    (=> 'inst.i32.div_s'))
    (case 'inst.i32.div_u'    (=> 'inst.i32.div_u'))
    (case 'inst.i32_rem_s'    (=> 'inst.i32.rem_s'))
    (case 'inst.i32.rem_u'    (=> 'inst.i32.rem_u'))
    (case 'inst.i32.and'      (=> 'inst.i32.and'))
    (case 'inst.i32.or'       (=> 'inst.i32.or'))
    (case 'inst.i32.xor'      (=> 'inst.i32.xor'))
    (case 'inst.i32.shl'      (=> 'inst.i32.shl'))
    (case 'inst.i32.shr_s'    (=> 'inst.i32.shr_s'))
    (case 'inst.i32.shr_u'    (=> 'inst.i32.shr_u'))
    (case 'inst.i32.rotl'     (=> 'inst.i32.rotl'))
    (case 'inst.i32.rotr'     (=> 'inst.i32.rotr'))
    (case 'inst.i64.clz'      (=> 'inst.i64.clz'))
    (case 'inst.i64.ctx'      (=> 'inst.i64.ctx'))
    (case 'inst.i64.popcnt'   (=> 'inst.i64.popcnt'))
    (case 'inst.i64.add'      (=> 'inst.i64.add'))
    (case 'inst.i64.sub'      (=> 'inst.i64.sub'))
    (case 'inst.i64.mul'      (=> 'inst.i64.mul'))
    (case 'inst.i64.div_s'    (=> 'inst.i64.div_s'))
    (case 'inst.i64.div_u'    (=> 'inst.i64.div_u'))
    (case 'inst.i64.rem_s'    (=> 'inst.i64.rem_s'))
    (case 'inst.i64.rem_u'    (=> 'inst.i64.rem_u'))
    (case 'inst.i64.and'      (=> 'inst.i64.and'))
    (case 'inst.i64.or'       (=> 'inst.i64.or'))
    (case 'inst.i64.xor'      (=> 'inst.i64.xor'))
    (case 'inst.i64.shl'      (=> 'inst.i64.shl'))
    (case 'inst.i64.shr_s'    (=> 'inst.i64.shr_s'))
    (case 'inst.i64.shr_u'    (=> 'inst.i64.shr_u'))
    (case 'inst.i64.rotl'     (=> 'inst.i64.rotl'))
    (case 'inst.i64.rotr'     (=> 'inst.i64.rotr'))
    (case 'inst.f32.abs'      (=> 'inst.f32.abs'))
    (case 'inst.f32.neg'      (=> 'inst.f32.neg'))
    (case 'inst.f32.ceil'     (=> 'inst.f32.ceil'))
    (case 'inst.f32.floor'    (=> 'inst.f32.floor'))
    (case 'inst.f32.trunc'    (=> 'inst.f32.trunc'))
    (case 'inst.f32.nearest'  (=> 'inst.f32.nearest'))
    (case 'inst.f32.sqrt'     (=> 'inst.f32.sqrt'))
    (case 'inst.f32.add'      (=> 'inst.f32.add'))
    (case 'inst.f32.sub'      (=> 'inst.f32.sub'))
    (case 'inst.f32.mul'      (=> 'inst.f32.mul'))
    (case 'inst.f32.div'      (=> 'inst.f32.div'))
    (case 'inst.f32.min'      (=> 'inst.f32.min'))
    (case 'inst.f32.max'      (=> 'inst.f32.max'))
    (case 'inst.f32.copysign' (=> 'inst.f32.copysign'))
    (case 'inst.f64.abs'      (=> 'inst.f64.abs'))
    (case 'inst.f64.neg'      (=> 'inst.f64.neg'))
    (case 'inst.f64.ceil'     (=> 'inst.f64.ceil'))
    (case 'inst.f64.floor'    (=> 'inst.f64.floor'))
    (case 'inst.f64.trunc'    (=> 'inst.f64.trunc'))
    (case 'inst.f64.nearest'  (=> 'inst.f64.nearest'))
    (case 'inst.f64.sqrt'     (=> 'inst.f64.sqrt'))
    (case 'inst.f64.add'      (=> 'inst.f64.add'))
    (case 'inst.f64.sub'      (=> 'inst.f64.sub'))
    (case 'inst.f64.mul'      (=> 'inst.f64.mul'))
    (case 'inst.f64.div'      (=> 'inst.f64.div'))
    (case 'inst.f64.min'      (=> 'inst.f64.min'))
    (case 'inst.f64.max'      (=> 'inst.f64.max'))
    (case 'inst.f64.copysign' (=> 'inst.f64.copysign'))

    # Conversions
    (case 'inst.i32.wrap/i64'      (=> 'inst.i32.wrap/i64'))
    (case 'inst.i32.trunc_s/f32'   (=> 'inst.i32.trunc_s/f32'))
    (case 'inst.i32.trunc_s/f32'   (=> 'inst.i32.trunc_u/f32'))
    (case 'inst.i32.trunc_s/f64'   (=> 'inst.i32.trunc_s/f64'))
    (case 'inst.i32.trunc_u/f64'   (=> 'inst.i32.trunc_u/f64'))
    (case 'inst.i64.extend_s/i32'  (=> 'inst.i64.extend_s/i32'))
    (case 'inst.i64.extend_u/i32'  (=> 'inst.i64.extend_u/i32'))
    (case 'inst.i64.trunc_s/f32'   (=> 'inst.i64.trunc_s/f32'))
    (case 'inst.i64.trunc_u/f32'   (=> 'inst.i64.trunc_u/f32'))
    (case 'inst.i64.trunc_s/f64'   (=> 'inst.i64.trunc_s/f64'))
    (case 'inst.i64.trunc_u/f64'   (=> 'inst.i64.trunc_u/f64'))
    (case 'inst.f32.convert_s/i32' (=> 'inst.f32.convert_s/i32'))
    (case 'inst.f32.convert_u/i32' (=> 'inst.f32.convert_u/i32'))
    (case 'inst.f32.convert_s/i64' (=> 'inst.f32.convert_s/i64'))
    (case 'inst.f32.convert_u/i64' (=> 'inst.f32.convert_u/i64'))
    (case 'inst.f32.demote/f64'    (=> 'inst.f32.demote/f64'))
    (case 'inst.f64.convert_s/i32' (=> 'inst.f64.convert_s/i32'))
    (case 'inst.f64.convert_u/i32' (=> 'inst.f64.convert_u/i32'))
    (case 'inst.f64.convert_s/i64' (=> 'inst.f64.convert_s/i64'))
    (case 'inst.f64.convert_u/i64' (=> 'inst.f64.convert_u/i64'))
    (case 'inst.f64.promote/f32'   (=> 'inst.f64.promote/f32'))


    # Reinterpretations
    (case 'inst.i32.reinterpret/f32' (=> 'inst.i32.reinterpret/f32'))
    (case 'inst.i64.reinterpret/f64' (=> 'inst.i64.reinterpret/f64'))
    (case 'inst.f32.reinterpret/i32' (=> 'inst.f32.reinterpret/i32'))
    (case 'inst.f64.reinterpret/i64' (=> 'inst.f64.reinterpret/i64'))
  )
  (=> 'instruction.end')
)

(define 'instruction.opcode' (params) (uint8))

(define 'local_entry' (params)
  (=> 'local_entry.begin')
  (varuint32)
  (=> 'local_entry.count')
  (eval 'type.value')
  (=> 'local_entry.end')
)

(define 'memory.section' (params)
  (=> 'memory.section.begin')
  (loop
    (seq (varuint32) (=> 'memory.section.count'))
    (eval 'memory_type')
    (=> 'memory.section.entry')
  )
  (=> 'memory.section.end')
)

(define 'memory_immediate' (params)
  (=> 'memory_immediate.begin')
  (varuint32)                  # log2 alignment/flags
  (varuint32)                  # offset
  (=> 'memory_immediate.end')
)

(define 'name.section' (params) # todo: fix.
  (=> 'name.section.begin')
  (loop
    (seq (varuint32) (=> 'name.section.count'))
    (eval 'function_names'))
  (=> 'name.section.end')
)

(define 'memory_type' (params)
  (=> 'memory_type.begin')
  (eval 'resizable_limits')
  (=> 'memory_type.end')
)

(define 'resizable_limits' (params)
  (locals 1)
  (=> 'resizable_limits.begin')
  (set (local 0) (varuint32))
  (=> 'resizable_limits.flags')
  (varuint32)
  (=> 'resizable_limits.initial')
  (if (bitwise.and (local 0) (u32.const 0x1))
    (seq
      (varuint32)
      (=> 'resizable_limits.maximum')
    )
  )
  (=> 'resizable_limits.end')
)

(define 'section' (params)
  (locals 1)
  (=> 'section.begin')
  (set (local 0) (varuint32))
  (=> 'section.code')
  (block
    (switch (local 0)
      (error)
      (case 'unknown.section' (eval 'unknown.section'))
      (case 'type.section' (eval 'type.section'))
      (case 'import.section' (eval 'import.section'))
      (case 'function.section' (eval 'function.section'))
      (case 'table.section' (eval 'table.section'))
      (case 'memory.section' (eval 'memory.section'))
      (case 'global.section' (eval 'global.section'))
      (case 'export.section' (eval 'export.section'))
      (case 'start.section' (eval 'start.section'))
      (case 'element.section' (eval 'element.section'))
      (case 'code.section' (eval 'code.section'))
      (case 'data.section' (error))
    )
  )
  (=> 'section.end')
)

(define 'skip_section' (params)
  (=> 'skip_section.begin')
  (loop.unbounded (uint8))
  (=> 'skip_section.end')
)

(define 'start.section' (params)
  (=> 'start.section.begin')
  (varuint32)
  (=> 'start.section.end')
)

(define 'symbol_name' (params)
  # Note: This define is understood by the reader. (TODO: karlschimpf)
  (=> 'symbol_name.begin')
  (loop
    (seq (varuint32) (=> 'symbol_name.length'))
    (uint8))
  (=> 'symbol_name.end')
)

(define 'table.section' (params)
  (=> 'table.section.begin')
  (loop
    (seq (varuint32) (=> 'table.section.count'))
    (eval 'table_type')
    (=> 'table.section.type')
  )
  (=> 'table.section.end')
) 

(define 'table_type' (params)
  (=> 'table_type.begin')
  (eval 'type.value')
  (eval 'resizable_limits')
  (=> 'table_type.end')
)

(define 'type.section' (params)
  (=> 'type.section.begin')
  (loop (seq (varuint32) (=> 'type_section.count'))
    (eval 'function_type')
  )
  (=> 'type.section.end')
)

(define 'type.value' (params)
  (=> 'type.value.begin')
  (varint32)
  (=> 'type.value.end')
)

(define 'unknown.section' (params)
  (=> 'unknown.section.begin')
  (eval 'symbol_name')
  (eval 'unknown_body')
  (=> 'unknown.section.end')
)

(define 'unknown_body' (params)
  (if (last.symbol.is 'name')
    (eval 'name.section')
    (eval 'skip_section')
  )
)

# Copyright 2015 WebAssembly Community Group participants
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


# This file defines the default algorithms for decompressing a WASM
# module, version 0xC.

(wasm.version 0xc)
(casm.version 0x0)
(section 'filter'
  (define 'code' (params)
    (loop
      (seq (varuint32) (=> 'code.num.functions'))
      (eval 'code.function'))
    (=> 'code.end.section')
  )

  (define 'code.address' (params)
    (varuint32)                  # log2 alignment/flags
    (varuint32)                  # offset
    (=> 'code.address')
  )

  (define 'code.br_table' (params)
    (loop
      (seq (varuint32) (=> 'code.br_table.size'))
      (varuint32)
      ('cod.br.target.depth'))
    (varuint32)
    (=> 'code.br.default.target.depth')
  )

  (define 'code.br_target' (params)
     (varuint32)
     (=> 'code.br_target')
  )

  (define 'code.function' (params)
    (block  # block implicitly reads bytes using (varuint32) on byte stream.
      (=> 'code.function.begin')
      (loop
        (seq (varuint32) (=> 'code.function.num.locals'))
        (eval 'code.funtion.local'))
      (=> 'code.function.bytes')
      (loop.unbounded
        (eval 'code.opcode')     # reads instruction opcode
        (eval 'code.inst'))      # selects/parses corresponding instruction.
      (=> 'code.function.end')
    )
  )

  (define 'code.inst' (params)
    (switch (seq (read) (=> 'code.opcode'))
      (error)

      # control flow operators.
      (case (u8.const 0x00)
        (=> 'code.inst.unreachable'))
      (case (u8.const 0x01)
        (uint8)
        (=> 'code.inst.block'))
      (case (u8.const 0x02)
        (uint8)
        (=> 'code.inst.loop'))
      (case (u8.const 0x03)
        (uint8)
        (=> 'code.inst.if'))
      (case (u8.const 0x04)
        (=> 'code.inst.else'))
      (case (u8.const 0x05)
        (=> 'code.inst.select'))
      (case (u8.const 0x06)
        (varuint32)
        (varuint32)
        (=> 'code.inst.br'))
      (case (u8.const 0x07)
        (varuint32)
        (varuint32)
        (=> 'code.inst.br_if'))
      (case (u8.const 0x08)
        (eval 'code.br_table')
        (=> 'code.inst.br_table'))
      (case (u8.const 0x09)
        (=> 'code.inst.return'))
      (case (u8.const 0x0a)
        (=> 'code.inst.nop'))
      (case (u8.const 0x0b)
        (=> 'code.inst.drop'))
      (case (u8.const 0x0f)
        (=> 'code.inst.end'))

      # basic operators
      (case (u8.const 0x10)
        (varint32)
        (=> 'code.inst.i32.const'))
      (case (u8.const 0x11)
        (varint64)
        (=> 'code.inst.i64.const'))
      (case (u8.const 0x12)
        (uint64)
        (=> 'code.inst.f64.const'))
      (case (u8.const 0x13)
        (uint32)
        (=> 'code.inst.f32.const'))
      (case (u8.const 0x14)
        (varuint32)
        (=> 'code.inst.get_local'))
      (case (u8.const 0x15)
        (varuint32)
        (=> 'code.inst.set_local'))
      (case (u8.const 0x19)
        (varuint32)
        (=> 'code.inst.tee_local'))
      (case (u8.const 0xbb)
        (varuint32)
        (=> 'code.inst.get_global))
      (case (u8.const 0xbc)
        (varuint32)
        (=> 'code.inst.set_global))
      (case (u8.const 0x16)
        (varuint32)
         (=> 'code.inst.call'))
      (case (u8.const 0x17)
        (varuint32)
        (=> 'code.inst.call_indirect'))

      # Memory-related operators
      (case (u8.const 0x20)
        (eval 'code.address')
        (=> 'code.inst.i32.load8_s'))
      (case (u8.const 0x21)
        (eval 'code.address')
        (=> 'code.inst.i32.load8_u'))
      (case (u8.const 0x22)
        (eval 'code.address')
        (=> 'code.inst.i32.load16_s'))
      (case (u8.const 0x23)
        (eval 'code.address')
        (=> 'code.inst.i32.load16_u'))
      (case (u8.const 0x24)
        (eval 'code.address')
        (=> 'code.inst.i64.load8_s'))
      (case (u8.const 0x25)
        (eval 'code.address')
        (=> 'code.inst.i64.load8_u))
      (case (u8.const 0x26)
        (eval 'code.address')
        (=> 'code.inst.i64.load16_s))
      (case (u8.const 0x27)
        (eval 'code.address')
        (=> 'code.inst.i64.load16_u'))
      (case (u8.const 0x28)
        (eval 'code.address')
        (=> 'code.inst.i64.load32_s'))
      (case (u8.const 0x29)
        (eval 'code.address')
        (=> 'code.inst.i64.load32_u))
      (case (u8.const 0x2a)
        (eval 'code.address')
        (=> 'code.inst.i32.load'))
      (case (u8.const 0x2b)
        (eval 'code.address')
        (=> 'code.inst.i64.load))
      (case (u8.const 0x2c)
        (eval 'code.address')
        (=> 'code.inst.f32.load'))
      (case (u8.const 0x2d)
        (eval 'code.address')
        (=> 'code.inst.f64.load'))
      (case (u8.const 0x2e)
        (eval 'code.address')
        (=> 'code.inst.i32.store8'))
      (case (u8.const 0x2f)
        (eval 'code.address')
        (=> 'code.inst.i32.store16'))
      (case (u8.const 0x30)
        (eval 'code.address')
        (=> 'code.inst.i64.store8'))
      (case (u8.const 0x31)
        (eval 'code.address')
        (=> 'code.inst.i64.store16'))
      (case (u8.const 0x32)
        (eval 'code.address')
        (=> 'code.inst.i64.store32'))
      (case (u8.const 0x33)
        (eval 'code.address')
        (=> 'code.inst.i32.store'))
      (case (u8.const 0x34)
        (eval 'code.address')
        (=> 'code.inst.i64.store'))
      (case (u8.const 0x35)
        (eval 'code.address')
        (=> 'code.inst.f32.store'))
      (case (u8.const 0x36)
        (eval 'code.address')
        (=> 'code.inst.f64.store'))
      (case (u8.const 0x3b)
        (eval 'code.address')
        (=> 'code.inst.current_memory'))
      (case (u8.const 0x39)
        (eval 'code.address')
        (=> 'code.inst.grow_memory'))

      # Simple operators
      (case (u8.const 0x40) (=> 'i32.add'))
      (case (u8.const 0x41) (=> 'i32.sub'))
      (case (u8.const 0x42) (=> 'i32.mul'))
      (case (u8.const 0x43) (=> 'i32.div_s'))
      (case (u8.const 0x44) (=> 'i32.div_u'))
      (case (u8.const 0x45) (=> 'i32.rem_s'))
      (case (u8.const 0x46) (=> 'i32.rem_u'))
      (case (u8.const 0x47) (=> 'i32.and'))
      (case (u8.const 0x48) (=> 'i32.or'))
      (case (u8.const 0x49) (=> 'i32.xor'))
      (case (u8.const 0x4a) (=> 'i32.shl'))
      (case (u8.const 0x4b) (=> 'i32.shr_u'))
      (case (u8.const 0x4c) (=> 'i32.shr_s'))
      (case (u8.const 0xb6) (=> 'i32.rotr'))
      (case (u8.const 0xb7) (=> 'i32.rotl'))
      (case (u8.const 0x4d) (=> 'i32.eq'))
      (case (u8.const 0x4e) (=> 'i32.ne'))
      (case (u8.const 0x4f) (=> 'i32.lt_s'))
      (case (u8.const 0x50) (=> 'i32.le_s'))
      (case (u8.const 0x51) (=> 'i32.lt_u'))
      (case (u8.const 0x52) (=> 'i32.le_u'))
      (case (u8.const 0x53) (=> 'i32.gt_s'))
      (case (u8.const 0x54) (=> 'i32.ge_s'))
      (case (u8.const 0x55) (=> 'i32.gt_u'))
      (case (u8.const 0x56) (=> 'i32.ge_u'))
      (case (u8.const 0x57) (=> 'i32.clz'))
      (case (u8.const 0x58) (=> 'i32.ctz'))
      (case (u8.const 0x59) (=> 'i32.popcnt'))
      (case (u8.const 0x5a) (=> 'i32.eqz'))
      (case (u8.const 0x5b) (=> 'i64.add'))
      (case (u8.const 0x5c) (=> 'i64.sub'))
      (case (u8.const 0x5d) (=> 'i64.mul'))
      (case (u8.const 0x5e) (=> 'i64.div_s'))
      (case (u8.const 0x5f) (=> 'i64.div_u'))
      (case (u8.const 0x60) (=> 'i64.rem_s'))
      (case (u8.const 0x61) (=> 'i64.rem_u'))
      (case (u8.const 0x62) (=> 'i64.and'))
      (case (u8.const 0x63) (=> 'i64.or'))
      (case (u8.const 0x64) (=> 'i64.xor'))
      (case (u8.const 0x65) (=> 'i64.shl'))
      (case (u8.const 0x66) (=> 'i64.shr_u'))
      (case (u8.const 0x67) (=> 'i64.shr_s'))
      (case (u8.const 0xb8) (=> 'i64.rotr'))
      (case (u8.const 0xb9) (=> 'i64.rotl'))
      (case (u8.const 0x68) (=> 'i64.eq'))
      (case (u8.const 0x69) (=> 'i64.ne'))
      (case (u8.const 0x6a) (=> 'i64.lt_s'))
      (case (u8.const 0x6b) (=> 'i64.le_s'))
      (case (u8.const 0x6c) (=> 'i64.lt_u'))
      (case (u8.const 0x6d) (=> 'i64.le_u'))
      (case (u8.const 0x6e) (=> 'i64.gt_s'))
      (case (u8.const 0x6f) (=> 'i64.ge_s'))
      (case (u8.const 0x70) (=> 'i64.gt_u'))
      (case (u8.const 0x71) (=> 'i64.ge_u'))
      (case (u8.const 0x72) (=> 'i64.clz'))
      (case (u8.cosnt 0x73) (=> 'i64.ctx'))
      (case (u8.const 0x74) (=> 'i64.popcnt'))
      (case (u8.const 0x75) (=> 'f32.add'))
      (case (u8.const 0x76) (=> 'f32.sub'))
      (case (u8.const 0x77) (=> 'f32.mul'))
      (case (u8.const 0x78) (=> 'f32.div'))
      (case (u8.const 0x79) (=> 'f32.min'))
      (case (u8.const 0x7a) (=> 'f32.max'))
      (case (u8.const 0x7b) (=> 'f32.abs'))
      (case (u8.const 0x7c) (=> 'f32.neg'))
      (case (u8.const 0x7d) (=> 'f32.copysign))
      (case (u8.const 0x7e) (=> 'f32.ceil'))
      (case (u8.const 0x7f) (=> 'f32.floor'))
      (case (u8.const 0x80) (=> 'f32.trunc'))
      (case (u8.const 0x81) (=> 'f32.nearest'))
      (case (u8.const 0x82) (=> 'f32.sqrt'))
      (case (u8.const 0x83) (=> 'f32.eq'))
      (case (u8.const 0x84) (=> 'f32.ne'))
      (case (u8.const 0x85) (=> 'f32.lt'))
      (case (u8.const 0x86) (=> 'f32.le'))
      (case (u8.const 0x87) (=> 'f32.gt'))
      (case (u8.const 0x88) (=> 'f32.ge'))
      (case (u8.const 0x89) (=> 'f64.add'))
      (case (u8.const 0x8a) (=> 'f64.sub'))
      (case (u8.const 0x8b) (=> 'f64.mul'))
      (case (u8.const 0x8c) (=> 'f64.div'))
      (case (u8.const 0x8d) (=> 'f64.min'))
      (case (u8.const 0x8e) (=> 'f64.max'))
      (case (u8.const 0x8f) (=> 'f64.abs'))
      (case (u8.const 0x90) (=> 'f64.neg'))
      (case (u8.const 0x91) (=> 'f64.copysign'))
      (case (u8.const 0x92) (=> 'f64.ceil'))
      (case (u8.const 0x93) (=> 'f64.floor'))
      (case (u8.const 0x94) (=> 'f64.trunc'))
      (case (u8.const 0x95) (=> 'f64.nearest'))
      (case (u8.const 0x96) (=> 'f64.sqrt'))
      (case (u8.const 0x97) (=> 'f64.eq'))
      (case (u8.const 0x98) (=> 'f64.ne'))
      (case (u8.const 0x99) (=> 'f64.lt'))
      (case (u8.const 0x9a) (=> 'f64.le'))
      (case (u8.const 0x9b) (=> 'f64.gt'))
      (case (u8.const 0x9c) (=> 'f64.ge'))
      (case (u8.const 0x9d) (=> 'i32.trunc_s/f32'))
      (case (u8.const 0x9e) (=> 'i32.trunc_s/f64'))
      (case (u8.const 0x9f) (=> 'i32.trunc_u/f32'))
      (case (u8.const 0xa0) (=> 'i32.trunc_u/f64'))
      (case (u8.const 0xa1) (=> 'i32.wrap/i64'))
      (case (u8.const 0xa2) (=> 'i64.trunc_s/f32'))
      (case (u8.const 0xa3) (=> 'i64.trunc_s/f64'))
      (case (u8.const 0xa4) (=> 'i64.trunc_u/f32'))
      (case (u8.const 0xa5) (=> 'i64.trunc_u/f64'))
      (case (u8.const 0xa6) (=> 'i64.extend_s/i32'))
      (case (u8.const 0xa7) (=> 'i64.extend_u/i32'))
      (case (u8.const 0xa8) (=> 'f32.convert_s/i32'))
      (case (u8.const 0xa9) (=> 'f32.convert_u/i32'))
      (case (u8.const 0xaa) (=> 'f32.convert_s/i64'))
      (case (u8.const 0xab) (=> 'f32.convert_u/i64'))
      (case (u8.const 0xac) (=> 'f32.demote/f64'))
      (case (u8.const 0xad) (=> 'f32.reinterpret/i32'))
      (case (u8.const 0xae) (=> 'f64.convert_s/i32'))
      (case (u8.const 0xaf) (=> 'f64.convert_u/i32'))
      (case (u8.const 0xb0) (=> 'f64.convert_s/i64'))
      (case (u8.const 0xb1) (=> 'f64.convert_u/i64'))
      (case (u8.const 0xb2) (=> 'f64.promote/f32'))
      (case (u8.const 0xb3) (=> 'f64.reinterpret/i64'))
      (case (u8.const 0xb4) (=> 'i32.reinterpret/f32'))
      (case (u8.const 0xb5) (=> 'i64.reinterpret/f64'))
    )
  )

  (define 'code.function.local' (params)
    (varuint32)                  # number of locals with type
    (uint8)                      # type of locals.
    (=> 'code.function.local')
  )

  (define 'code.opcode' (params) (uint8))

  (define 'data' (params)
    (loop
      (seq (varuint32) (=> 'data.num.segments))
      (eval 'data.segment'))
    (=> 'data.end.segment')
  )

  (define 'data.segment' (params)
    (varuint32)                # The linear memory index.
    (eval '$init_expr')        # an i32 initializer defining offset to place data.
    (loop 
      (seq (varuint32) (=> 'data.num.segment.bytes))
      (uint8)) # The data.
    (=> 'data.segment')
  )

  (define 'element' (params)
    (loop
      (seq (varuint32) (=> 'element.num.elements'))
      (eval 'element.segment')
    )
    (=> 'element.end.section')
  )

  (define 'element.segment' (params)
    (varuint32)                 # The table index
    (eval '$init_expr')         # An i32 initializer that computess the
                                # placement offset.
    (loop
      (seq (varuint32) (=> 'element.num.segment.elements')
      (varuint32)
      (=> 'element.segment.element')
    )
    (=> 'element.segment')
  )

  (define 'export' (params)
    (loop 
      (seq (varuint32) (=> 'export.num.entries'))
      (eval 'export.entry'))
    (=> 'export.end.section')
  )

  (define 'export.entry' (params)
    (eval 'name.symbol')       # Exported field name.
    (uint8)                    # Kind of definition being exported.
    (varuint32)                # The index to the corresponding index space.
    (=> 'export.entry')
  )

  (define 'function' (params)
    (loop
      (seq (varuint32) (=> 'function.num.signatures'))
      (varuint32)
      (=> 'function.signature')
    )
    (=> 'function.end.section')
  )

  (define 'global' (params)
    (loop (seq (varuint32) (=> 'global.num.vars'))
      (uint8)                    # Type of global variable
      (uint8)                    # 0 if immutable, 1 if mutable.
      (=> 'global.var.header')
      (eval '$init_expr')         # Initial value if specified.
      (=> 'global.var')
    )
    (=> 'global.end.section')
  )

  (define 'import' (params)
    (loop 
      (seq (varuint32) (=> 'import.num.entries'))
      (eval 'import.entry')
    )
    (=> 'import.end.section')
  )

  (define 'import.entry' (params)
    (varuint32)                    # signature index of the import
    (eval 'name.symbol')           # module name
    (eval 'name.symbol')           # field name
    (=> 'import.entry')
    (switch (uint8)                # Kind of definition.
      (error)
      (case (u8.const 0)           # Function:
        (varuint32)
        (=> 'import.function'))
      (case (u8.const 1)           # Table:
        (uint8)                    #     0x20, indicating anyfunc.
        (eval '$resizable_limits')
        (=> 'import.table'))
      (case (u8.const 2)           # Memory:
        (eval '$resizable_limits')
        (=> 'import.memory'))
      (case (u8.const 3)           # Global:
        (uint8)                    #     Type of imported global.
        (uint8)                    #     0=immutable, 1=mutable.
        (=> 'import.global'))
    )
  )

  (define '$init_expr' (params)
    (eval 'code.opcode')      # Opcode of expression.
    (switch (seq (read) (=> '$init.expr.opcode'))
      (error)                 # Only allows explicitly allowed operands.
      (case (u8.const 0x10)
        (varint32)
        (=> '$init_expr.i32.const'))
      (case (u8.const 0x11)
        (varint64)
        (=> '$init_expr.i64.const'))
      (case (u8.const 0x12)
        (uint64)
        (=> '$init_expr.f64.const'))
      (case (u8.const 0x13)
        (uint32)
        (=> '$init_expr.f32.const))
      (case (u8.const 0xbb)
        (varuint32)
        (=> '$init_expr.get_global'))
      (case (u8.const 0x0f) (=> '$init_expr.end')
    )
    (=> '$init_expr.define')
  )

  (define 'memory' (params)
    (loop
      (seq (varuint32) (=> 'memory.num.decls')
      (eval '$resizable_limits')  # memory unit limits.
    )
    (=> 'memory.end.section')
  )

  (define 'name' (params)
    (loop
      (seq (varuint32) (=> 'name.num.functions'))
      (eval 'name.function'))
    (=> 'name.end.section')
  )

  (define 'name.function' (params)
    (eval 'name.symbol')       # function name
    (loop
      (seq (varuint32) (=> 'name.function.num.locals))
      (eval 'name.symbol'))    # local name
    (=> 'name.function')
  )

  (define 'name.symbol' (params)
    (loop
      (seq (varuint32) (=> 'name.symbol.length')
      (uint8))
    (=> 'name.symbol')
  )

  (define '$resizable_limits' (params)
    (locals 1)
    (set (local 0) (varuint32))
    (varuint32) (=> '$resizable_limits.initial.length')
    (if (bitwise.and (local 0) (u32.const 0x1))
      (varuint32)
      (=> '$resizable_limits.maximum.length)
    )
    (=> '$resizable_limits')
  )

  (define 'start' (params)
    (varuint32)                # start function index.
    (=> 'start.function')
    (=> 'start.end.section')
  )

  (define 'table' (params)
    (loop
      (seq (varuint32) (=> 'table.num.entries'))
      (uint8)                   # 0x20, indicating anyfunc.
      (eval '$resizable_limits') # Table entry limits.
      (=> 'table.entry')
    )
    (=> 'table.end.section')
  ) 

  (define 'type' (params)
    (loop (seq (varuint32) (=> 'type.num.signatures'))
      (uint8)                  # type form (0x040)
      (loop
        (seq (varuint32) (=> 'type.num.params'))
        (uint8)
        (=> 'type.param')
      )
      (loop
        (seq (varuint32) (=> 'type.num.returns'))
        (uint8)
        (=> 'type.return')
      )
    )
    (=> 'type.end.section')
  )
)

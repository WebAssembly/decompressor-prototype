/* -*- C++ -*- */
/*
 * Copyright 2016 WebAssembly Community Group participants
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

%skeleton "lalr1.cc"

/* Textual parser for filter s-expressions */

%defines
%define api.namespace {wasm::filt}
%define parser_class_name {Parser}

%define api.token.constructor
%define api.value.type variant
%define parse.assert

%code requires {
#include "sexp/Ast.h"
#include "stream/WriteUtils.h"
#include <string>

namespace wasm {
namespace filt {
class Driver;
class Node;

struct IntegerValue {
  wasm::decode::IntType Value;
  wasm::decode::ValueFormat Format;
};

}}

#ifdef __clang__
// TODO: Limit the reach of these pragma's?
#pragma clang diagnostic ignored "-Wdeprecated-register"
#pragma clang diagnostic ignored "-Wundefined-inline"
#endif // __clang__
}

// The parsing context.
%param { class Driver& Driver }

%locations
%initial-action
{
  // Initialize the initial location.
  @$.begin.filename = @$.end.filename = &Driver.getFilename();
};

%define parse.trace
%define parse.error verbose

%code
{
// Note: Must follow definitions above, so that location_type is declared.
# include "Driver.h"

}

// Special tokens
%token END 0 "$END"

// Keywords
%token AND           "and"
%token AST           "ast"
%token BIT           "bit"
%token BLOCK         "block"
%token BLOCKEND      "block.end"
%token BYTE          "byte"
%token CASE          "case"
%token CLOSEPAREN    ")"
%token DEFAULT       "default"
%token DEFINE        "define"
%token ERROR         "error"
%token EVAL          "eval"
%token EVAL_DEFAULT  "eval.default"
%token FILTER        "filter"
%token IF            "if"
%token IN            "in"
%token INT           "int"
%token I32_CONST     "i32.const"
%token I64_CONST     "i64.const"
%token LOOP          "loop"
%token LOOP_UNBOUNDED "loop.unbounded"
%token NOT           "not"
%token OPCODE        "opcode"
%token OPENPAREN     "("
%token OR            "or"
%token OUT           "out"
%token PEEK          "peek"
%token READ          "read"
%token SECTION       "section"
%token SELECT        "select"
%token SEQ           "seq"
%token STREAM        "stream"
%token UINT8         "uint8"
%token UINT32        "uint32"
%token UINT64        "uint64"
%token UNDEFINE      "undefine"
%token U8_CONST      "u8.const"
%token U32_CONST     "u32.const"
%token U64_CONST     "u64.const"
%token VARINT32      "varint32"
%token VARINT64      "varint64"
%token VARUINT32     "varuint32"
%token VARUINT64     "varuint64"
%token VERSION       "version"
%token VOID          "void"
%token WRITE         "write"

// Terminal classes
%token <wasm::filt::ExternalName> IDENTIFIER
%token <wasm::filt::IntegerValue> INTEGER

// Nonterminal classes.
%type <wasm::filt::Node *> block_stmt_list
%type <wasm::filt::Node *> bool_expression
%type <wasm::filt::Node *> case
%type <wasm::filt::SelectNode *> case_list
%type <wasm::filt::Node *> case_stmt_list
%type <wasm::filt::Node *> constant_expression
%type <wasm::filt::Node *> declaration
%type <wasm::filt::SectionNode *> declaration_list
%type <wasm::filt::Node *> declaration_stmt_list
%type <wasm::filt::Node *> expression
%type <wasm::filt::Node *> file
%type <wasm::filt::Node *> fixed_format_directive
%type <wasm::filt::Node *> format_directive
%type <wasm::filt::Node *> loop_body
%type <wasm::filt::Node *> opcode_case
%type <wasm::filt::Node *> opcode_selector
%type <wasm::filt::OpcodeNode *> opcode_expression
%type <wasm::filt::Node *> stream
%type <wasm::filt::Node *> stream_conv
%type <wasm::filt::Node *> stream_conv_list
%type <wasm::filt::Node *> stream_conv_stmt_list
%type <wasm::decode::StreamKind> stream_kind
%type <wasm::decode::StreamType> stream_type
%type <wasm::filt::Node *> section
%type <wasm::filt::Node *> section_list
%type <wasm::filt::Node *> seq_stmt_list
%type <wasm::filt::Node *> statement
%type <wasm::filt::Node *> symbol
%type <wasm::filt::Node *> version

%start file

%%

file    : section_list {
            $$ = $1;
            Driver.setParsedAst($1);
          }
        ;

case    : "(" "case" case_stmt_list ")" { $$ = $3; }
        ;

case_list
        : expression statement { // selector / default statement.
            $$ = Driver.create<SelectNode>();
            $$->append($1);
            $$->append($2);
          }
        | case_list case {
            $$ = $1;
            $$->append($2);
          }
        ;

case_stmt_list
        : constant_expression statement { // case index / first statement of case.
            $$ = Driver.create<CaseNode>($1, $2);
          }
        | case_stmt_list statement { // remaining statements of case.
            $$ = $1;
            Node *StmtList = $1->getLastKid();
            auto *Seq = dyn_cast<SequenceNode>(StmtList);
            if (Seq == nullptr) {
              Seq = Driver.create<SequenceNode>();
              Seq->append(StmtList);
              $1->setLastKid(Seq);
            }
            Seq->append($2);
          }
        ;

constant_expression
        : "(" "i32.const" INTEGER ")" {
            $$ = Driver.create<I32ConstNode>($3.Value, $3.Format);
          }
        | "(" "i64.const" INTEGER ")" {
            $$ = Driver.create<I64ConstNode>($3.Value, $3.Format);
          }
        | "(" "u8.const" INTEGER ")" {
            $$ = Driver.create<U8ConstNode>($3.Value, $3.Format);
          }
        | "(" "u32.const" INTEGER ")" {
            $$ = Driver.create<U32ConstNode>($3.Value, $3.Format);
          }
        | "(" "u64.const" INTEGER ")" {
            $$ = Driver.create<U64ConstNode>($3.Value, $3.Format);
          }
        ;

declaration
        : "(" declaration_stmt_list ")" {
            $$ = $2;
          }
        | "(" "undefine" symbol ")" {
            $$ = Driver.create<UndefineNode>($3);
          }
        ;

declaration_stmt_list
        : "default" symbol statement {
            $$ = Driver.create<DefaultNode>($2, $3);
          }
        | "define" symbol statement {
            $$ = Driver.create<DefineNode>($2, $3);
          }
        | declaration_stmt_list statement {
            $$ = $1;
            Node *StmtList = $1->getLastKid();
            auto *Seq = dyn_cast<SequenceNode>(StmtList);
            if (Seq == nullptr) {
              Seq = Driver.create<SequenceNode>();
              Seq->append(StmtList);
              $1->setLastKid(Seq);
            }
            Seq->append($2);
          }
        ;

declaration_list
        : symbol version {  // Section name / version.
            $$ = Driver.create<SectionNode>();
            $$->append($1);
            $$->append($2);
          }
          | declaration_list declaration { // defines etc.
            $$ = $1;
            $$->append($2);
          }
        ;

block_stmt_list
        : "block" statement  {
            $$ = Driver.create<BlockNode>($2);
          }
        | block_stmt_list statement {
            $$ = $1;
            Node *StmtList = $1->getLastKid();
            auto *Seq = dyn_cast<SequenceNode>(StmtList);
            if (Seq == nullptr) {
              Seq = Driver.create<SequenceNode>();
              Seq->append(StmtList);
              $1->setLastKid(Seq);
            }
            Seq->append($2);
          }
        ;

bool_expression
        : "(" "and" expression expression ")" {
            $$ = Driver.create<AndNode>($3, $4);
          }
        | stream { $$ = $1; }
        | "(" "not" expression ")" {
            $$ = Driver.create<NotNode>($3);
          }
        | "(" "or" expression expression ")" {
            $$ = Driver.create<OrNode>($3, $4);
          }
        ;

expression
        : format_directive { $$ = $1; }
        | constant_expression { $$ = $1; }
        | bool_expression { $$ = $1; }
        | "(" "block.end" ")" {
            $$ = Driver.create<BlockEndNoArgsNode>();
          }
        | "(" "error" ")" {
            $$ = Driver.create<ErrorNode>();
          }
        | "(" "eval" symbol ")" {
            $$ = Driver.create<EvalNode>($3);
          }
        | "(" "eval.default" symbol ")" {
            $$ = Driver.create<EvalDefaultNode>($3);
          }
        | "(" "write" expression expression ")" {
            $$ = Driver.create<WriteNode>($3, $4);
          }
        | "(" "peek" expression ")" {
            $$ = Driver.create<PeekNode>($3);
          }
        | "(" "read" ")" {
            $$ = Driver.create<LastReadNode>();
          }
        | "(" "read" expression ")" {
            $$ = Driver.create<ReadNode>($3);
          }
        ;

format_directive
        : fixed_format_directive { $$ = $1; }
        | "(" "varint32" ")" {
            $$ = Driver.create<Varint32NoArgsNode>();
          }
        | "(" "varint32" INTEGER ")" {
            if ($3.Value < 2 || $3.Value > 32)
              Driver.error("varint32 expects 2 <= bitsize <= 32");
            $$ = Driver.create<Varint32OneArgNode>($3.Value, $3.Format);
          }
        | "(" "varint64" ")" {
            $$ = Driver.create<Varint64NoArgsNode>();
          }
        | "(" "varint64" INTEGER ")" {
            if ($3.Value < 2 || $3.Value > 64)
              Driver.error("varint64 expects 2 <= bitsize <= 64");
            $$ = Driver.create<Varint64OneArgNode>($3.Value, $3.Format);
          }
        | "(" "varuint32" ")" {
            $$ = Driver.create<Varuint32NoArgsNode>();
          }
        | "(" "varuint32" INTEGER ")" {
            if ($3.Value < 2 || $3.Value > 32)
              Driver.error("varuint32 expects 2 <= bitsize <= 32");
            $$ = Driver.create<Varuint32OneArgNode>($3.Value, $3.Format);
          }
        | "(" "varuint64" ")" {
            $$ = Driver.create<Varuint64NoArgsNode>();
          }
        | "(" "varuint64" INTEGER ")" {
            if ($3.Value < 2 || $3.Value > 64)
              Driver.error("varuint64 expects 2 <= bitsize <= 64");
            $$ = Driver.create<Varuint64OneArgNode>($3.Value, $3.Format);
          }
        | "(" "opcode" opcode_expression ")" {
            $$ = $3;
          }
        ;

fixed_format_directive
        : "(" "void" ")" {
            $$ = Driver.create<VoidNode>();
          }
        | "(" "uint8" ")" {
            $$ = Driver.create<Uint8NoArgsNode>();
          }
        | "(" "uint8" INTEGER ")" {
            if ($3.Value > 8)
              Driver.error("uint8 bitsize > 8");
            $$ = Driver.create<Uint8OneArgNode>($3.Value, $3.Format);
          }
        | "(" "uint32" ")" {
            $$ = Driver.create<Uint32NoArgsNode>();
          }
        | "(" "uint32" INTEGER ")"  {
            if ($3.Value > 32)
              Driver.error("uint32 bitsize > 32");
            $$ = Driver.create<Uint32OneArgNode>($3.Value, $3.Format);
          }
        | "(" "uint64" ")" {
            $$ = Driver.create<Uint64NoArgsNode>();
          }
        | "(" "uint64" INTEGER ")"  {
            if ($3.Value > 64)
              Driver.error("uint64 bitsize > 64");
            $$ = Driver.create<Uint64OneArgNode>($3.Value, $3.Format);
          }
        ;

opcode_expression
        : opcode_selector {
            $$ = Driver.create<OpcodeNode>();
            $$->append($1);
          }
        | opcode_expression opcode_case {
            $$ = $1;
            $$->append($2);
          }
        ;

opcode_selector
        : fixed_format_directive { $$ = $1; }
        | "(" "eval" symbol ")" {
            /* TODO(karlschimpf): Should we allow this? */
            $$ = Driver.create<EvalNode>($3);
          }
        ;

opcode_case
        : "(" "case" constant_expression expression  ")" {
            $$ = Driver.create<CaseNode>($3, $4);
          }
        ;

version : "(" "version" INTEGER ")" {
            if ($3.Value != 0)
              Driver.error("Currently, only (version 0) is supported");
            $$ = Driver.create<VersionNode>($3.Value, $3.Format);
          }
        ;

loop_body
        : "loop" expression statement {
            $$ = Driver.create<LoopNode>($2, $3);
          }
        | "loop.unbounded" statement {
            $$ = Driver.create<LoopUnboundedNode>($2);
          }
        | loop_body statement {
            $$ = $1;
            Node *StmtList = $1->getLastKid();
            auto *Seq = dyn_cast<SequenceNode>(StmtList);
            if (Seq == nullptr) {
              Seq = Driver.create<SequenceNode>();
              Seq->append(StmtList);
              $1->setLastKid(Seq);
            }
            Seq->append($2);
          }
        ;

section : "(" "section" declaration_list ")" { $$ = $3; }
        ;

section_list
        : section { // first section of file.
            $$ = Driver.create<FileNode>();
            $$->append($1);
          }
        | section_list section { // Remaining sections in file.
            $$ = $1;
            $$->append($2);
          }
        ;

seq_stmt_list
        : %empty {
            $$ = Driver.create<SequenceNode>();
          }
        | seq_stmt_list statement {
            $$ = $1;
            $$->append($2);
          }
        ;

statement
        : expression { $$ = $1; }
        | stream_conv { $$ = $1; }
        | "(" block_stmt_list ")"  { $$ = $2; }
        | "(" "filter" stream_conv_list ")" { $$ = $3; }
        | "(" "if" expression statement ")" {
            $$ = Driver.create<IfThenNode>($3, $4);
          }
        | "(" "if" expression statement statement ")" {
            $$ = Driver.create<IfThenElseNode>($3, $4, $5);
          }
        | "(" loop_body ")" { $$ = $2; }
        | "(" "select" case_list ")" {
            $$ = $3;
          }
        | "(" "seq" seq_stmt_list ")" { $$ = $3; }
        ;

stream
        : "(" "stream" stream_kind stream_type ")" {
            $$ = Driver.create<StreamNode>($3, $4);
          }
        ;

stream_kind
        : "in" { $$ = decode::StreamKind::Input; }
        | "out" { $$ = decode::StreamKind::Output; }
        ;

stream_type
        : "bit" { $$ = decode::StreamType::Bit; }
        | "byte" { $$ = decode::StreamType::Byte; }
        | "int" { $$ = decode::StreamType::Int; }
        | "ast" { $$ = decode::StreamType::Ast; }
        ;

stream_conv
        : "(" stream_conv_stmt_list ")" {
            $$ = $2;
          }
        ;

stream_conv_list
        : stream_conv {
            $$ = Driver.create<FilterNode>();
            $$->append($1);
          }
        | stream_conv_list stream_conv {
            $$ = $1;
            $$->append($2);
          }
        ;

stream_conv_stmt_list
       : "convert" stream stream statement {
            $$ = Driver.create<ConvertNode>($2, $3, $4);
          }
        | stream_conv_stmt_list statement {
            $$ = $1;
            Node *StmtList = $1->getLastKid();
            auto *Seq = dyn_cast<SequenceNode>(StmtList);
            if (Seq == nullptr) {
              Seq = Driver.create<SequenceNode>();
              Seq->append(StmtList);
              $1->setLastKid(Seq);
            }
            Seq->append($2);
          }
        ;

symbol  : IDENTIFIER { $$ = Driver.getSymbolDefinition($1); }
        ;

%%

void wasm::filt::Parser::error(const location_type& L, const std::string& M) {
  Driver.error(L, M);
}

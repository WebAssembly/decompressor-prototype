/* -*- C++ -*- */
/*
 * Copyright 2016 WebAssembly Community Group participants
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

%skeleton "lalr1.cc"

/* Textual parser for filter s-expressions */

%defines
%define api.namespace {wasm::filt}
%define parser_class_name {Parser}

%define api.token.constructor
%define api.value.type variant
%define parse.assert

%code requires {
#include "sexp/Ast.h"
#include <string>

namespace wasm {
namespace filt {
class Driver;
class Node;

struct IntegerValue {
  wasm::decode::IntType Value;
  wasm::filt::IntegerNode::ValueFormat Format;
};

}}

#ifdef __clang__
// TODO: Limit the reach of these pragma's?
#pragma clang diagnostic ignored "-Wdeprecated-register"
#pragma clang diagnostic ignored "-Wundefined-inline"
#endif // __clang__
}

// The parsing context.
%param { class Driver& Driver }

%locations
%initial-action
{
  // Initialize the initial location.
  @$.begin.filename = @$.end.filename = &Driver.getFilename();
};

%define parse.trace
%define parse.error verbose

%code
{
// Note: Must follow definitions above, so that location_type is declared.
# include "Driver.h"

}

// Special tokens
%token END 0 "$END"

// Keywords
%token BLOCK         "block"
%token BLOCKBEGIN    "block.begin"
%token BLOCKEND      "block.end"
%token BYTE_TO_BYTE  "byte.to.byte"
%token CASE          "case"
%token CLOSEPAREN    ")"
%token DEFAULT       "default"
%token DEFINE        "define"
%token ERROR         "error"
%token EVAL          "eval"
%token FILTER        "filter"
%token I32_CONST     "i32.const"
%token I64_CONST     "i64.const"
%token LIT           "lit"
%token LOOP          "loop"
%token LOOP_UNBOUNDED "loop.unbounded"
%token OPENPAREN     "("
%token MAP           "map"
%token PEEK          "peek"
%token READ          "read"
%token SECTION       "section"
%token SELECT        "select"
%token SEQ           "seq"
%token SYM_CONST     "sym.const"
%token UINT8         "uint8"
%token UINT32        "uint32"
%token UINT64        "uint64"
%token UNDEFINE      "undefine"
%token U32_CONST     "u32.const"
%token U64_CONST     "u64.const"
%token VARINT32      "varint32"
%token VARINT64      "varint64"
%token VARUINT32     "varuint32"
%token VARUINT64     "varuint64"
%token VERSION       "version"
%token VOID          "void"

// Terminal classes
%token <wasm::filt::ExternalName> IDENTIFIER
%token <wasm::filt::IntegerValue> INTEGER

// Nonterminal classes.
%type <wasm::filt::Node *> case
%type <wasm::filt::Node *> case_list
%type <wasm::filt::Node *> case_statement_list
%type <wasm::filt::Node *> declaration
%type <wasm::filt::Node *> declaration_list
%type <wasm::filt::Node *> declaration_stmt_list
%type <wasm::filt::Node *> expression
%type <wasm::filt::Node *> file
%type <wasm::filt::IntegerNode *> integer
%type <wasm::filt::Node *> stream_conv
%type <wasm::filt::Node *> stream_conv_list
%type <wasm::filt::Node *> stream_conv_stmt_list
%type <wasm::filt::Node *> header
%type <wasm::filt::Node *> loop_body
%type <wasm::filt::Node *> section
%type <wasm::filt::Node *> section_list
%type <wasm::filt::Node *> seq_statement_list
%type <wasm::filt::Node *> statement
%type <wasm::filt::Node *> symbol

%start file

%%

file    : section_list {
            $$ = $1;
            Driver.setParsedAst($1);
          }
        ;

case    : "(" "case" case_statement_list ")" { $$ = $3; }
        ;

case_list
        : expression statement { // selector / default statement.
            $$ = Driver.create<Nary<OpSelect>>();
            $$->append($1);
            $$->append($2);
          }
        | case_list case {
            $$ = $1;
            $$->append($2);
          }
        ;

case_statement_list
        : integer statement { // case index / first statement of case.
            $$ = Driver.create<Binary<OpCase>>($1, $2);
          }
        | case_statement_list statement { // remaining statements of case.
            $$ = $1;
            Node *StmtList = $1->getKid(1);
            auto *Seq = dyn_cast<Nary<OpSequence>>(StmtList);
            if (Seq == nullptr) {
              Seq = Driver.create<Nary<OpSequence>>();
              Seq->append(StmtList);
              $1->setKid(1, Seq);
            }
            Seq->append($2);
          }
        ;

declaration
        : "(" declaration_stmt_list ")" {
            $$ = $2;
          }
        | "(" "undefine" symbol ")" {
            $$ = Driver.create<Unary<OpUndefine>>($3);
          }
        ;

declaration_stmt_list
        : "default" symbol statement {
            $$ = Driver.create<Binary<OpDefault>>($2, $3);
          }
        | "define" symbol statement {
            $$ = Driver.create<Binary<OpDefine>>($2, $3);
          }
        | declaration_stmt_list statement {
            $$ = $1;
            Node *StmtList = $1->getKid(1);
            auto *Seq = dyn_cast<Nary<OpSequence>>(StmtList);
            if (Seq == nullptr) {
              Seq = Driver.create<Nary<OpSequence>>();
              Seq->append(StmtList);
              $1->setKid(1, Seq);
            }
            Seq->append($2);
          }
        ;

declaration_list
        : symbol declaration {  // Section name / first define.
            $$ = Driver.create<Nary<OpSection>>();
            $$->append($1);
            $$->append($2);
          }
          | declaration_list declaration { // Additional defines.
            $$ = $1;
            $$->append($2);
          }
        ;

expression
        : "(" "block" expression ")" {
            // 1st argument is width in bytes
            $$ = Driver.create<Unary<OpBlockOneArg>>($3);
          }
        | "(" "block" expression integer ")" {
            // 1st argument is width in bytes
            // 2nd argument is block.end value to inject
            $$ = Driver.create<Binary<OpBlockTwoArgs>>($3, $4);
          }
        | "(" "block" expression integer integer ")" {
            // 1st argument is width in bytes
            // 2nd argument is block.begin value to inject
            // 3nd argument is block.end value to inject
            $$ = Driver.create<Ternary<OpBlockThreeArgs>>($3, $4, $5);
          }
        | "(" "block.begin" ")" {
            $$ = Driver.create<Nullary<OpBlockBegin>>();
          }
        | "(" "block.end" ")" {
            $$ = Driver.create<Nullary<OpBlockEnd>>();
          }
        | "(" "error" ")" {
            $$ = Driver.create<Nullary<OpError>>();
          }
        | "(" "eval" symbol ")" {
            $$ = Driver.create<Unary<OpEval>>($3);
          }
        | "(" "i32.const" integer ")" {
            $$ = Driver.create<Unary<OpI32Const>>($3);
          }
        | "(" "i64.const" integer ")" {
            $$ = Driver.create<Unary<OpI64Const>>($3);
          }
        | "(" "lit" integer ")" {
            $$ = Driver.create<Unary<OpLit>>($3);
          }
        | "(" "map" expression expression ")" {
            $$ = Driver.create<Binary<OpMap>>($3, $4);
          }
        | "(" "peek" expression ")" {
            $$ = Driver.create<Unary<OpPeek>>($3);
          }
        | "(" "read" expression ")" {
            $$ = Driver.create<Unary<OpRead>>($3);
          }
        | "(" "sym.const" symbol ")" {
            $$ = Driver.create<Unary<OpSymConst>>($3);
          }
        | "(" "uint8" ")" {
            $$ = Driver.create<Nullary<OpUint8NoArgs>>();
          }
        | "(" "uint8" integer ")" {
            if ($3->getValue() > 8)
              Driver.error("uint8 bitsize > 8");
            $$ = Driver.create<Unary<OpUint8OneArg>>($3);
          }
        | "(" "uint32" ")" {
            $$ = Driver.create<Nullary<OpUint32NoArgs>>();
          }
        | "(" "uint32" integer ")"  {
            if ($3->getValue() > 32)
              Driver.error("uint32 bitsize > 32");
            $$ = Driver.create<Unary<OpUint32OneArg>>($3);
          }
        | "(" "uint64" ")" {
            $$ = Driver.create<Nullary<OpUint64NoArgs>>();
          }
        | "(" "uint64" integer ")"  {
            if ($3->getValue() > 64)
              Driver.error("uint64 bitsize > 64");
            $$ = Driver.create<Unary<OpUint64OneArg>>($3);
          }
        | "(" "u32.const" integer ")" {
            $$ = Driver.create<Unary<OpU32Const>>($3);
          }
        | "(" "u64.const" integer ")" {
            $$ = Driver.create<Unary<OpU64Const>>($3);
          }
        | "(" "varint32" ")" {
            $$ = Driver.create<Nullary<OpVarint32NoArgs>>();
          }
        | "(" "varint32" integer ")" {
            decode::IntType Bitsize = $3->getValue();
            if (Bitsize < 2 || Bitsize > 32)
              Driver.error("varint32 expects 2 <= bitsize <= 32");
            $$ = Driver.create<Unary<OpVarint32OneArg>>($3);
          }
        | "(" "varint64" ")" {
            $$ = Driver.create<Nullary<OpVarint64NoArgs>>();
          }
        | "(" "varint64" integer ")" {
            decode::IntType Bitsize = $3->getValue();
            if (Bitsize < 2 || Bitsize > 64)
              Driver.error("varint64 expects 2 <= bitsize <= 64");
            $$ = Driver.create<Unary<OpVarint64OneArg>>($3);
          }
        | "(" "varuint32" ")" {
            $$ = Driver.create<Nullary<OpVaruint32NoArgs>>();
          }
        | "(" "varuint32" integer ")" {
            decode::IntType Bitsize = $3->getValue();
            if (Bitsize < 2 || Bitsize > 32)
              Driver.error("varuint32 expects 2 <= bitsize <= 32");
            $$ = Driver.create<Unary<OpVaruint32OneArg>>($3);
          }
        | "(" "varuint64" ")" {
            $$ = Driver.create<Nullary<OpVaruint64NoArgs>>();
          }
        | "(" "varuint64" integer ")" {
            decode::IntType Bitsize = $3->getValue();
            if (Bitsize < 2 || Bitsize > 64)
              Driver.error("varuint64 expects 2 <= bitsize <= 64");
            $$ = Driver.create<Unary<OpVaruint64OneArg>>($3);
          }
        | "(" "void" ")" {
            $$ = Driver.create<Nullary<OpVoid>>();
          }
        ;

header  : "(" "version" integer ")" {
            if ($3->getValue() != 0)
              Driver.error("Currently, only (version 0) is supported");
            $$ = Driver.create<Unary<OpVersion>>($3);
          }
        ;

integer : INTEGER {
           $$ = Driver.create<IntegerNode>($1.Value, $1.Format);
          }

loop_body
        : "loop" expression {
           $$ = Driver.create<Nary<OpLoop>>();
            $$->append($2);
          }
        | "loop.unbounded" {
            $$ = Driver.create<Nary<OpLoopUnbounded>>();
          }
        | loop_body statement {
            $$ = $1;
            $$->append($2);
          }
        ;

section : "(" "section" declaration_list ")" { $$ = $3; }
        ;

section_list
        : header section { // Header / first section of file.
            $$ = Driver.create<Nary<OpFile>>();
            $$->append($1);
            $$->append($2);
          }
        | section_list section { // Remaining sections in file.
            $$ = $1;
            $$->append($2);
          }
        ;

seq_statement_list
        : %empty {
            $$ = Driver.create<Nary<OpSequence>>();
          }
        | seq_statement_list statement {
            $$ = $1;
            $$->append($2);
          }
        ;

statement
        : expression { $$ = $1; }
        | stream_conv { $$ = $1; }
        | "(" "filter" stream_conv_list ")" { $$ = $3; }
        | "(" loop_body ")" { $$ = $2; }
        | "(" "select" case_list ")" { $$ = $3; }
        | "(" "seq" seq_statement_list ")" { $$ = $3; }
        ;

stream_conv  : "(" stream_conv_stmt_list ")" {
            $$ = $2;
          }
        ;

stream_conv_list
        : stream_conv {
            $$ = Driver.create<Nary<OpFilter>>();
            $$->append($1);
          }
        | stream_conv_list stream_conv {
            $$ = $1;
            $$->append($2);
          }
        ;

stream_conv_stmt_list
       : "byte.to.byte" statement {
            $$ = Driver.create<Unary<OpByteToByte>>($2);
          }
        | stream_conv_stmt_list statement {
            $$ = $1;
            Node *StmtList = $1->getKid(0);
            auto *Seq = dyn_cast<Nary<OpSequence>>(StmtList);
            if (Seq == nullptr) {
              Seq = Driver.create<Nary<OpSequence>>();
              Seq->append(StmtList);
              $1->setKid(0, Seq);
            }
            Seq->append($2);
          }
        ;

symbol  : IDENTIFIER { $$ = Driver.getSymbol($1); }
        ;

%%

void wasm::filt::Parser::error(const location_type& L, const std::string& M) {
  Driver.error(L, M);
}
